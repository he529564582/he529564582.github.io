<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>he</title>
  <meta name="author" content="何方">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="he">

  
    <meta property="og:image" content>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="he" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">he</a></h1>
  <h2><a href="/"></a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/常见排序算法">常见排序算法</a></h1>
  

      
        <time datetime="2019-05-21T06:48:42.894Z">2019-05-21</time>
      
    </header>
    <div class="entry">
      
        <h3 id="常见排序算法-冒泡排序-Bubble-Sort"><a href="#常见排序算法-冒泡排序-Bubble-Sort" class="headerlink" title="常见排序算法 - 冒泡排序 (Bubble Sort)"></a>常见排序算法 - 冒泡排序 (Bubble Sort)</h3><h4 id="冒泡排序算法的流程如下："><a href="#冒泡排序算法的流程如下：" class="headerlink" title="冒泡排序算法的流程如下："></a>冒泡排序算法的流程如下：</h4><p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3、针对所有的元素重复以上的步骤，除了最后一个。<br>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h5 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h5><p>以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：<br>第一次外循环</p>
<pre><code>( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变
</code></pre><p>第二次外循环（除开最后一个元素8，对剩余的序列）</p>
<pre><code>( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变
</code></pre><p>第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）</p>
<pre><code>( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
</code></pre><p>第四次外循环（最后一次）</p>
<pre><code>( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
</code></pre><h4 id="JavaScript-语言实现"><a href="#JavaScript-语言实现" class="headerlink" title="JavaScript 语言实现"></a>JavaScript 语言实现</h4><pre><code>function bubbleSort(array) {
var length = array.length,
i,
j,
temp;
for (i = length - 1; 0 &lt; i; i--) {
for (j = 0; j &lt; i; j++) {
        if (array[j] &gt; array[j + 1]) {
        temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
        }
}
}
return array;
}
</code></pre><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://www.processon.com/view/link/5ce3a2f1e4b0e03e4216ac80" target="_blank" rel="noopener">预览地址</a></p>
<h3 id="常见排序算法-选择排序-Selection-Sort"><a href="#常见排序算法-选择排序-Selection-Sort" class="headerlink" title="常见排序算法 - 选择排序 (Selection Sort)"></a>常见排序算法 - 选择排序 (Selection Sort)</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h5 id="实例分析：-1"><a href="#实例分析：-1" class="headerlink" title="实例分析："></a>实例分析：</h5><p>以数组 arr = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节<br>第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）：</p>
<pre><code>                               min
                                ↓
8   5   2   6   9   3   1   4   0   7
↑                               ↑
└───────────────────────────────┘
</code></pre><p>交换后：</p>
<pre><code>0   5   2   6   9   3   1   4   8   7
</code></pre><p>在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换：</p>
<pre><code>                       min
                        ↓
0   5   2   6   9   3   1   4   8   7
↑                   ↑
└───────────────────┘
</code></pre><p>交换后：</p>
<pre><code>0   1   2   6   9   3   5   4   8   7
</code></pre><p>在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）：</p>
<pre><code>       min
        ↓
0   1   2   6   9   3   5   4   8   7
        ↑
</code></pre><p> 重复上述过程，直到最后一个元素就完成了排序。</p>
<pre><code>                   min
                    ↓
0   1   2   6   9   3   5   4   8   7
            ↑       ↑
            └───────┘
                           min
                            ↓
0   1   2   3   9   6   5   4   8   7
                ↑           ↑
                └───────────┘
                       min
                        ↓
0   1   2   3   4   6   5   9   8   7
                    ↑   ↑
                    └───┘
                       min
                        ↓
0   1   2   3   4   5   6   9   8   7
                        ↑   
                                   min
                                    ↓
0   1   2   3   4   5   6   9   8   7
                            ↑       ↑
                            └───────┘  
                               min
                                ↓
0   1   2   3   4   5   6   7   8   9
                                ↑      
                                   min
                                    ↓
0   1   2   3   4   5   6   7   8   9
                                    ↑
</code></pre><h4 id="JavaScript-语言实现-1"><a href="#JavaScript-语言实现-1" class="headerlink" title="JavaScript 语言实现"></a>JavaScript 语言实现</h4><pre><code>function selectionSort(array) {
var length = array.length,
i,
j,
minIndex,
minValue,
temp;
for (i = 0; i &lt; length - 1; i++) {
minIndex = i;
minValue = array[minIndex];
for (j = i + 1; j &lt; length; j++) {
if (array[j] &lt; minValue) {
        minIndex = j;
        minValue = array[minIndex];
}
}
// 交换位置
temp = array[i];
array[i] = minValue;
array[minIndex] = temp;
}
return array
}
</code></pre><h4 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://www.processon.com/view/link/5ce3b60de4b0f34230d661f4" target="_blank" rel="noopener">预览地址</a></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/原型与原型链">原型与原型链</a></h1>
  

      
        <time datetime="2018-12-24T11:20:17.000Z">2018-12-24</time>
      
    </header>
    <div class="entry">
      
        <h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><pre><code>function Person(name){
    this.name = name;
    this.age = age;
}
Person.prototype.sayName = function(){
    console.log(this.name);
}

var p1 = new Person(&apos;a&apos;);
var p2 = new Person(&apos;b&apos;);
p1.sayName();  
p2.sayName();  
</code></pre><p>1.new 一个函数本质上做了什么？<br>  1)创建了一个空的对象<br>  2)空对象的<strong>proto</strong>指向了类Modal()的prototype<br>  3)在执行函数的过程中，给this赋值，函数里的this代表了空对象，返回出去<br>  4)将this赋值给modal<br>2.通过函数定义了一个类Person，它自动获取了属性prototype，<br>每个类的实例也就是p1、p2内部都会有一个<strong>proto</strong>的属性，如下图:<br><img src="http://video.jirengu.com/xdml/image/996010fa-de82-489f-9b0a-20943cd224cf/2018-12-10-22-29-34.png" alt="image1"></p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>当前的p1实例，查找toString()的方法先从p1的属性里找，<br>没有找到,再从 p1.<strong>proto</strong> 中找，没有找到,<br>再从 p1.<strong>proto</strong>.<strong>proto</strong> 中找，找到后返回<br><img src="http://video.jirengu.com/xdml/image/996010fa-de82-489f-9b0a-20943cd224cf/2018-12-11-15-9-42.png" alt="image2"></p>
<h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><pre><code>function People(){}
var p = new People()
p.__proto__ === People.prototype 
People.__proto__ === Function.prototype
People.prototype.__proto__ === Object.prototype
</code></pre><p><img src="https://pic1.zhimg.com/b6aa8d4260e78ce3618e0d85febc2bbc_r.jpg" alt="image3"><br>（1）People函数创建了对象 p，所以People.prototype === p.<strong>proto</strong>；<br>（2）Object函数创建了People.prototype对象，所以Object.prototype === People.prototype.<strong>proto</strong>；<br>（3）People 作为对象的角色被函数Function创建，所以 Function.prototype === People.<strong>proto</strong>;</p>
<h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><p><img src="https://pic3.zhimg.com/c2891fbeeb0530ef61885c0e6414170a_r.jpg" alt="image4"><br>（1）任何函数都是 Function 创建，所以Function 创建了 Function，所以 Function.prototype === Function.<strong>proto</strong>；<br>（2）Object 也是函数。所以Function创建了Object，所以 Function.prototype === Object.<strong>proto</strong> ；<br>（3）Function.prototype 是普通对象，普通对象是由Object创建的，所以 Function.prototype.<strong>proto</strong> === Object.prototype</p>
<h3 id="例子5"><a href="#例子5" class="headerlink" title="例子5"></a>例子5</h3><pre><code>Object instanceof Function
Function instanceof Object
Function instanceof Function
Object instanceof Object
</code></pre><p>instanceof的作用是判断一个对象是不是一个函数的实例。比如obj instanceof fn,<br>实际上是判断fn的prototype是不是在obj的原型链上。<br>比如: </p>
<pre><code>obj.__proto__ === fn.prototype
obj.__proto__.__proto__ === fn.prototype
obj.__proto__..._proto__ === fn.prototype
</code></pre><p>只要一个成立即可。<br>1.对于Function instanceof Function,<br>因为 Function.<strong>proto</strong> === Function.prototype<br>所以为true。</p>
<p>2.对于Object instanceof Object,<br>因为 Object.<strong>proto</strong>.<strong>proto</strong> === Function.prototype.<strong>proto</strong> === Object.prototype,<br>所以为true</p>
<p>3.对于Function instanceof Object,<br>因为 Function.<strong>proto</strong>.<strong>proto</strong> === Function.prototype.<strong>proto</strong> === Object.prototype,<br>所以为true</p>
<p>4.对于Object instanceof Function,因为 Object.<strong>proto</strong> === Function.prototype<br>所以为true</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/动画队列">动画队列</a></h1>
  

      
        <time datetime="2018-12-11T12:08:40.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h2 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h2><p>jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。</p>
<h3 id="stop-clearQueue-jumpToEnd-（添加版本1-2）"><a href="#stop-clearQueue-jumpToEnd-（添加版本1-2）" class="headerlink" title=".stop( [clearQueue ] [, jumpToEnd ] )（添加版本1.2）"></a>.stop( [clearQueue ] [, jumpToEnd ] )（添加版本1.2）</h3><p>clearQueue<br>类型: Boolean<br>一个布尔值，指示是否取消以列队动画。默认 false.<br>jumpToEnd<br>类型: Boolean<br>一个布尔值指示是否当前动画立即完成。默认false.</p>
<h3 id="stop-queue-clearQueue-jumpToEnd-（添加版本1-7）"><a href="#stop-queue-clearQueue-jumpToEnd-（添加版本1-7）" class="headerlink" title=".stop( [queue ] [, clearQueue ] [, jumpToEnd ] )（添加版本1.7）"></a>.stop( [queue ] [, clearQueue ] [, jumpToEnd ] )（添加版本1.7）</h3><p>queue<br>类型: String<br>停止动画队列的名称。<br>clearQueue<br>类型: Boolean<br>一个布尔值，指示是否取消以列队动画。默认 false.<br>jumpToEnd<br>类型: Boolean<br>一个布尔值指示是否当前动画立即完成。默认false.<br>jQuery中有stop这个方法可以停止当前执行的动画，并且它有两个布尔参数，默认值都为false。</p>
<pre><code>clearQueue(default: false)
jumpToEnd(default: false)
</code></pre><p>第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以，我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后面的队列丢弃了，这就会出现意料之外的结果。</p>
<p>###<br>我们可以看到如下整理结果:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop()</td>
<td></td>
<td>清空队列，当前执行动作立即停止。后续动作会不再执行。 等同于：stop(false,false)</td>
</tr>
<tr>
<td>stop(true)</td>
<td>[clearQueue]</td>
<td>清空队列，当前执行动作立即停止。后续动作会不再执行</td>
</tr>
<tr>
<td>stop(true,true)</td>
<td>[clearQueue],[gotoEnd]</td>
<td>清空队列，当前执行动作<font color="red" size="5">立即完成</font>。后续动作会不再执行</td>
</tr>
<tr>
<td>stop(true,false)</td>
<td>[clearQueue],[gotoEnd]</td>
<td>清空队列，当前执行动作立即停止。后续动作会不再执行</td>
</tr>
<tr>
<td>stop(false)</td>
<td>[clearQueue]</td>
<td>不清空队列，当前执行动作立即停止。后续动作会立即执行</td>
</tr>
<tr>
<td>stop(false,true)</td>
<td>[clearQueue],[gotoEnd]</td>
<td>不清空队列，当前执行动作<font color="red" size="5">立即完成</font>。后续动作会立即执行</td>
</tr>
<tr>
<td>stop(false,false)</td>
<td>[clearQueue],[gotoEnd]</td>
<td>不清空队列，当前执行动作立即停止。后续动作会立即执行</td>
</tr>
</tbody>
</table>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/js作用域相关介绍">js作用域</a></h1>
  

      
        <time datetime="2018-12-11T12:08:26.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h4 id="JavaScript的作用域是什么"><a href="#JavaScript的作用域是什么" class="headerlink" title="JavaScript的作用域是什么"></a>JavaScript的作用域是什么</h4><p>作用域，在维基百科上解释是：在电脑程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。<br>简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。</p>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<p>(1）程序最外层定义的函数或者变量<br>var a = “tsrot”;<br>function hello(){<br>    alert(a);<br>}</p>
<p>function sayHello(){<br>    hello();<br>}</p>
<p>alert(a);     //能访问到tsrot<br>hello();      //能访问到tsrot<br>sayHello();   //能访问到hello函数，然后也能访问到tsrot<br>（2）所有末定义直接赋值的变量（不推荐）<br>function hello(){<br>    a = “tsrot”;<br>    var b = “hello tsrot”;<br>}</p>
<p>alert(a);  //能访问到tsrot<br>alert(b);  //error 不能访问<br>（3）所有window对象的属性和方法<br>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。</p>
<h4 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h4><p>局部作用域在函数内创建，在函数内可访问，函数外不可访问。<br>function hello(){<br>    var a = “tsrot”;<br>    alert(a);<br>}</p>
<p>hello(); //函数内可访问到tsrot<br>alert(a); //error not defined</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/介绍浏览器的渲染机制">浏览器的渲染机制</a></h1>
  

      
        <time datetime="2018-12-11T12:06:35.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h3 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h3><p>首先当用户输入一个URL的时候，浏览器就会发送一个请求，请求URL对应的资源。<br>然后浏览器的HTML解析器会将这个文件解析，并且构建成一棵DOM树。<br>在构建DOM树的时候，遇到JS和CSS元素，HTML解析器就换将控制权转让给JS解析器或者是CSS解析器。<br>JS解析器或者是CSS解析器解析完这个元素时候，HTML又继续解析下个元素，直到整棵DOM树构建完成。<br>DOM树构建完之后，浏览器把DOM树中的一些不可视元素去掉，然后与CSSOM合成一棵render树。<br>接着浏览器根据这棵render树，计算出各个节点(元素)在屏幕的位置。这个过程叫做layout，输出的是一棵layout树。<br>最后浏览器根据这棵layout树，将页面渲染到屏幕上去。</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/cookie&session&localStorage">cookie&amp;session&amp;localStorage</a></h1>
  

      
        <time datetime="2018-12-11T12:06:29.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h3 id="cookie-amp-session-amp-localStorage"><a href="#cookie-amp-session-amp-localStorage" class="headerlink" title="cookie&amp;session&amp;localStorage"></a>cookie&amp;session&amp;localStorage</h3><h4 id="一、cookie"><a href="#一、cookie" class="headerlink" title="一、cookie"></a>一、cookie</h4><p>cookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。在控制台用 「document.cookie」查看你当前正在浏览的网站的cookie。<br>cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用 HTTP 协议规定的 set-cookie 来让浏览器种下cookie，这是最常见的做法。（打开一个网站，清除全部cookie，然后刷新页面，在network的Response headers试试找一找set-cookie吧）<br>每次网络请求 Request headers 中都会带上cookie。所以如果 cookie 太多太大对传输效率会有影响。<br>一般浏览器存储cookie 最大容量为4k，所以大量数据不要存到cookie。<br>设置cookie时的参数：<br>path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。expires 和 maxAge：告诉浏览器 cookie 时候过期，maxAge 是 cookie 多久后过期的相对时间。不设置这两个选项时会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。<br>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效<br>httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。[cookie 参数][简述 Cookie 是什么]</p>
<h4 id="二、session"><a href="#二、session" class="headerlink" title="二、session"></a>二、session</h4><p>当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个session用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。<br>创建session后，会把关联的session_id 通过setCookie 添加到http响应头部中。<br>浏览器在加载页面时发现响应头部有 set-cookie字段，就把这个cookie 种到浏览器指定域名下。<br>当下次刷新页面时，发送的请求会带上这条cookie， 服务端在接收到后根据这个session_id来识别用户。<br>cookie 是存储在浏览器里的一小段「数据」，而session是一种让服务器能识别某个用户的「机制」，session 在实现的过程中需要使用cookie。当然有时候说到 session 也指服务器里创建的那个和用户身份关联的对象。</p>
<h4 id="三、localStorage"><a href="#三、localStorage" class="headerlink" title="三、localStorage"></a>三、localStorage</h4><p>localStorage HTML5本地存储web storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。<br>不参与网络传输。<br>一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/HTMLCollection 和 NodeList">HTMLCollection 和 NodeList</a></h1>
  

      
        <time datetime="2018-12-11T12:06:02.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h3 id="HTMLCollection-和-NodeList"><a href="#HTMLCollection-和-NodeList" class="headerlink" title="HTMLCollection 和 NodeList"></a>HTMLCollection 和 NodeList</h3><p>节点都是单个对象，有时会需要一种数据结构，能够容纳多个节点。DOM提供两种集合对象，用于实现这种节点的集合：NodeList和HTMLCollection。</p>
<p>NodeList 对象代表一个有顺序的节点列表，HTMLCollection 是一个接口，表示 HTML 元素的集合，它提供了可以遍历列表的方法和属性</p>
<p>以下方法获取的为HTMLCollection对象</p>
<pre><code>document.images //所有img元素
document.links //所有带href属性的a元素和area元素
document.forms //所有form元素
document.scripts //所有script元素
document.body.children
document.getElementsByClassName(&quot;class1&quot;)
</code></pre><p>以下方法获取的为NodeList对象</p>
<pre><code>document.getElementsByName(&quot;name1&quot;)
document.getElementsByTagName(&quot;a&quot;)
document.querySelectorAll(&quot;a&quot;)
document.body.childNodes
</code></pre><p>如何查看？</p>
<pre><code>document.body.childNodes.constructor
HTMLCollection与NodeList基本相似
</code></pre><p>相同点： 都是类数组对象，节点的变化都会实时反映在集合中</p>
<p>不同点： 少部分方法不一样，比如 NodeList 有 forEach 方法，而 HTMLCollection 没有</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/跨域(CORS)">CORS</a></h1>
  

      
        <time datetime="2018-12-11T12:04:53.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><h4 id="为什么要跨域？"><a href="#为什么要跨域？" class="headerlink" title="为什么要跨域？"></a>为什么要跨域？</h4><p>跨域问题是浏览器同源策略限制，当前域名的js只能读取同域下的窗口属性。<br>一个网站的网址组成包括协议名，子域名，主域名，端口号。比如 <a href="https://www.github.com/80，其中https是协议名,www.github.com是子域名，github.com是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在http://localhost:80/" target="_blank" rel="noopener">https://www.github.com/80，其中https是协议名,www.github.com是子域名，github.com是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在http://localhost:80/</a> 页面请求<a href="http://127.0.0.1:80" target="_blank" rel="noopener">http://127.0.0.1:80</a> 也会有跨域问题（因为域名不一样嘛~）</p>
<h4 id="跨域的实现的几种方式"><a href="#跨域的实现的几种方式" class="headerlink" title="跨域的实现的几种方式"></a>跨域的实现的几种方式</h4><h5 id="1、Jsonp"><a href="#1、Jsonp" class="headerlink" title="1、Jsonp"></a>1、Jsonp</h5><p>最常见的一种跨域方式，其背后的原理就是利用script标签不受同源策略的限制，在页面中动态插入script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理的函数名名告诉后端，后端在响应请求时会将函数回调返回，并且将数据以参数的形式传递回去<br>代码部分：</p>
<script src="http://api.sta.com/weather.php?callback=showData"></script>

<pre><code>&lt;script&gt;
    function showData(ret){
    console.log(ret);
    }
&lt;/script&gt;
</code></pre><h5 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h5><p>当使用XMLHttpRequest发送请求是，如果浏览器发现了违反了同源策略就会自动加上一个请求头：origin，后端在接受请求的时候确定响应后会在Response Headers中加入一个熟悉：Access-Control-Allow-Origin，value就是发起请求的源地址 <a href="http://127.0.0.1:8080，浏览器得到响应会继续判断Access-Control—Allow—Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理" target="_blank" rel="noopener">http://127.0.0.1:8080，浏览器得到响应会继续判断Access-Control—Allow—Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理</a></p>
<pre><code>var http = require(&apos;http&apos;)
var fs = require(&apos;fs&apos;)
var path = require(&apos;path&apos;)
var url = require(&apos;url&apos;)
http.createServer(function(req,res){
    var pathObj = url.parse(req.url,true)
    switch(pathObj.pathname){
        case &apos;/getWeather&apos;:
        var  weather =[
            &quot;beijing&quot;:&quot;sunny&quot;,
            &quot;shanghai&quot;:&quot;cloudy&quot;
        ]
        res.setHeader(&apos;Access-Control-Allow-Origin&apos;,http://localhost:8080)
        res.end(JSON.stringify(weather))
        break;
        default:
        fs.readFile(parse.join(__dirname,pathObj.pathname),function(e,data){
            if(e){
                res.writeHead(404, &apos;not found&apos;)
                res.end(&apos;&lt;h1&gt;404 not found&lt;/h1&gt;&apos;)
            }else{
                res.end(data)
            }
        })
    }
}).listen(8080)


 $(&apos;.change&apos;).addEventListener(&apos;click&apos;, function () {
    var xhr = new XMLHttpRequest();
    xhr.open(&apos;get&apos;, &apos;http://localhost:8080/getWeather&apos;, true);
    xhr.send();
    xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
        appendHtml(JSON.parse(xhr.responseText))
    }
    };
});
</code></pre><h5 id="2、window-postMessage-message-targetOrigin"><a href="#2、window-postMessage-message-targetOrigin" class="headerlink" title="2、window.postMessage(message,targetOrigin)"></a>2、window.postMessage(message,targetOrigin)</h5><p>方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。这种方法不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据 </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/数组扁平化">JavaScript专题之数组扁平化</a></h1>
  

      
        <time datetime="2018-12-11T12:03:24.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。</p>
<p>举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：</p>
<pre><code>var arr = [1, [2, [3, 4]]];
console.log(flatten(arr)) // [1, 2, 3, 4]
</code></pre><p>知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法：</p>
<pre><code>// 方法 1
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
    var result = [];
    for (var i = 0, len = arr.length; i &lt; len; i++) {
        if (Array.isArray(arr[i])) {
            result = result.concat(flatten(arr[i]))
        }
        else {
            result.push(arr[i])
        }
    }
    return result;
}
console.log(flatten(arr))
</code></pre><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：</p>
<p>[1, [2, [3, 4]]].toString() // “1,2,3,4”<br>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？</p>
<pre><code>// 方法2
var arr = [1, [2, [3, 4]]];

function flatten(arr) {
    return arr.toString().split(&apos;,&apos;).map(function(item){
        return +item
    })
}
console.log(flatten(arr))
</code></pre><p>然而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，这种方法就会产生错误的结果。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码：</p>
<pre><code>// 方法3
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.reduce(function(prev, next){
        return prev.concat(Array.isArray(next) ? flatten(next) : next)
    }, [])
}

console.log(flatten(arr))
</code></pre><p>…<br>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</p>
<p>var arr = [1, [2, [3, 4]]];<br>console.log([].concat(…arr)); // [1, 2, [3, 4]]<br>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</p>
<pre><code>// 方法4
var arr = [1, [2, [3, 4]]];

function flatten(arr) {

    while (arr.some(item =&gt; Array.isArray(item))) {
        arr = [].concat(...arr);
    }

    return arr;
}

console.log(flatten(arr))
</code></pre><h3 id="undercore"><a href="#undercore" class="headerlink" title="undercore"></a>undercore</h3><p>那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~</p>
<p>在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。</p>
<p>/**</p>
<ul>
<li>数组扁平化</li>
<li>@param  {Array} input   要处理的数组</li>
<li>@param  {boolean} shallow 是否只扁平一层</li>
<li>@param  {boolean} strict  是否严格处理元素，下面有解释</li>
<li>@param  {Array} output  这是为了方便递归而传递的参数</li>
<li><p>源码地址：<a href="https://github.com/jashkenas/underscore/blob/master/underscore.js#L528" target="_blank" rel="noopener">https://github.com/jashkenas/underscore/blob/master/underscore.js#L528</a><br>*/</p>
<pre><code>function flatten(input, shallow, strict, output) {

    // 递归使用的时候会用到output
    output = output || [];
    var idx = output.length;

    for (var i = 0, len = input.length; i &lt; len; i++) {

        var value = input[i];
        // 如果是数组，就进行处理
        if (Array.isArray(value)) {
            // 如果是只扁平一层，遍历该数组，依此填入 output
            if (shallow) {
                var j = 0, length = value.length;
                while (j &lt; length) output[idx++] = value[j++];
            }
            // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output
            else {
                flatten(value, shallow, strict, output);
                idx = output.length;
            }
        }
        // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output
        else if (!strict){
            output[idx++] = value;
        }
    }

    return output;

}
</code></pre><p>解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子：</p>
</li>
</ul>
<p>var arr = [1, 2, [3, 4]];<br>console.log(flatten(arr, true, true)); // [3, 4]<br>那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：</p>
<p>shallow true + strict false ：正常扁平一层<br>shallow false + strict false ：正常扁平所有层<br>shallow true + strict true ：去掉非数组元素<br>shallow false + strict true ： 返回一个[]<br>我们看看 underscore 中哪些方法调用了 flatten 这个基本函数：</p>
<h3 id="flatten"><a href="#flatten" class="headerlink" title="_.flatten"></a>_.flatten</h3><p>首先就是 _.flatten：</p>
<p>_.flatten = function(array, shallow) {<br>    return flatten(array, shallow, false);<br>};<br>在正常的扁平中，我们并不需要去掉非数组元素。</p>
<p>_.union<br>接下来是 _.union：</p>
<p>该函数传入多个数组，然后返回传入的数组的并集，</p>
<p>举个例子：</p>
<p>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2, 3, 101, 10]<br>如果传入的参数并不是数组，就会将该参数跳过：</p>
<p>_.union([1, 2, 3], [101, 2, 1, 10], 4, 5);<br>=&gt; [1, 2, 3, 101, 10]<br>为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。</p>
<pre><code>// 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27)
function unique(array) {
return Array.from(new Set(array));
}

_.union = function() {
    return unique(flatten(arguments, true, true));
}
</code></pre><p>_.difference<br>是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference：</p>
<p>语法为：</p>
<p>_.difference(array, *others)</p>
<p>效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。</p>
<p>举个例子：</p>
<p>_.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);<br>=&gt; [1, 3]<br>实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值：</p>
<pre><code>function difference(array, ...rest) {

    rest = flatten(rest, true, true);

    return array.filter(function(item){
        return rest.indexOf(item) === -1;
    })
}
</code></pre>
      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/Exercise-在此处输入这篇文章的分类。/随机生成IP、字符串、颜色等">随机生成ip、字符串、color</a></h1>
  

      
        <time datetime="2018-12-11T12:03:03.000Z">2018-12-11</time>
      
    </header>
    <div class="entry">
      
        <h3 id="随机生成ip、字符串、color"><a href="#随机生成ip、字符串、color" class="headerlink" title="随机生成ip、字符串、color"></a>随机生成ip、字符串、color</h3><p>//随机生成32位字符串</p>
<pre><code>function getRandomStr(len) {
    var a = &apos;&apos;
    var b =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;
    for (i = 0 ; i &lt;len; i++){
        var c = Math.floor(Math.random()*b.length)
        a += b[c]
    }
    return a
}
var a = getRandomStr(32)
console.log(a)
</code></pre><p>//随机生成一个IP地址</p>
<pre><code>function getRandIP(){
    var ip=[]
    for (i= 0 ; i&lt;4; i++){
        ip[i]= Math.floor(Math.random()*256)
    }
    return ip.join(&apos;.&apos;)
}
var ip = getRandIP()
console.log(ip)
</code></pre><p>//生成一个随机颜色字符串</p>
<pre><code>function getRandColor(){
    var color = &apos;#&apos;
    var dict =&apos;0123456abcdef&apos;
    for(i = 0; i &lt; 6; i++){
        var index =Math.floor(Math.random()*dict.length)
        color += dict[index]
    }
    return color
}
var color = getRandColor()
console.log(color)
</code></pre><p>//min到max之间的 随机整数</p>
<pre><code>function sum(min,max){
    var sum =Math.floor(Math.random()*(max-min))+min
    return sum
}
console.log(sum(1,100))
</code></pre>
      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>






<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hefang.site">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/Exercise-在此处输入这篇文章的分类。/常见排序算法">常见排序算法</a>
      </li>
    
      <li>
        <a href="/Exercise-在此处输入这篇文章的分类。/原型与原型链">原型与原型链</a>
      </li>
    
      <li>
        <a href="/Exercise-在此处输入这篇文章的分类。/动画队列">动画队列</a>
      </li>
    
      <li>
        <a href="/Exercise-在此处输入这篇文章的分类。/js作用域相关介绍">js作用域</a>
      </li>
    
      <li>
        <a href="/Exercise-在此处输入这篇文章的分类。/介绍浏览器的渲染机制">浏览器的渲染机制</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/Exercise-在此处输入这篇文章的分类。/">Exercise   //在此处输入这篇文章的分类。</a><small>11</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 何方
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



</body>
</html>

