{"meta":{"title":"he'blog","subtitle":null,"description":null,"author":"何方","url":"http://www.hefang.site","root":"/"},"pages":[{"title":"关于","date":"2018-11-30T16:52:39.000Z","updated":"2019-05-22T01:43:49.942Z","comments":true,"path":"about/index.html","permalink":"http://www.hefang.site/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-30T16:52:39.000Z","updated":"2019-05-22T01:42:21.441Z","comments":true,"path":"categories/index.html","permalink":"http://www.hefang.site/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2018-11-30T17:12:43.000Z","updated":"2019-05-22T04:20:31.527Z","comments":true,"path":"archives/index.html","permalink":"http://www.hefang.site/archives/index.html","excerpt":"","text":""},{"title":"资源","date":"2018-09-01T06:21:57.000Z","updated":"2019-05-22T01:43:15.717Z","comments":true,"path":"resources/index.html","permalink":"http://www.hefang.site/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-30T17:12:43.000Z","updated":"2019-05-22T01:42:14.097Z","comments":true,"path":"tags/index.html","permalink":"http://www.hefang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js笔记","slug":"vue日记29","date":"2019-07-11T12:42:29.000Z","updated":"2019-07-17T15:42:33.859Z","comments":true,"path":"2019/07/11/vue日记29/","link":"","permalink":"http://www.hefang.site/2019/07/11/vue日记29/","excerpt":"","text":"JS笔记标识符 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9 下面这些都是合法的标识符:1234arg0_tmp$elemπ 下面这些则是不合法的标识符:123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名 数据类型 ==（ES6 又新增了第七种 Symbol 类型的值)== 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值 undefined和null，一般将它们看成两个特殊值 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 typeof运算符可以返回一个值的数据类型数值、字符串、布尔值分别返回number、string、boolean null, undefinednull表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景 转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN “”或’’（空字符串） NaNNaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合 isNaN()isNaN方法可以用来判断一个值是否为NaN。12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。123isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // true**** 转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\’ ：单引号（\\u0027） \\” ：双引号（\\u0022） \\ ：反斜杠（\\u005C） 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象123var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true&apos;toString&apos; in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的==hasOwnProperty==方法判断一下，是否为对象自身的属性1234var obj = &#123;&#125;;if (&apos;toString&apos; in obj) &#123; console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false&#125; 函数作用域作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域 对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v ==注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量==1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2 ==总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域== 闭包12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁 ==闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在== 立即调用的函数表达式通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 类似数组的对象==数组的slice方法可以将“类似数组的对象”变成真正的数组==。1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，==就是通过call()把数组的方法放到对象上面==12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 取反运算符取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成f123alse，false变成true。å!true // false!false // true 对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 undefined null false 0 NaN 空字符串（’’） 12345678910!undefined // true!null // true!0 // true!NaN // true!&quot;&quot; // true!54 // false!&apos;hello&apos; // false![] // false!&#123;&#125; // false Object()instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例1234567891011var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object(&apos;foo&apos;);obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true 上面代码中，Object函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。 1234567891011var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 利用这一点，可以写一个判断变量是否为对象的函数。123456function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false Object.keys()，Object.getOwnPropertyNames()Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。 Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名123456var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj) // [&quot;p1&quot;, &quot;p2&quot;] Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。123456var obj = &#123; p1: 123, p2: 456&#125;;Object.getOwnPropertyNames(obj) // [&quot;p1&quot;, &quot;p2&quot;] 对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名1234var a = [&apos;Hello&apos;, &apos;World&apos;];Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;] 上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。[\\b] 匹配退格键(U+0008)，不要与\\b混淆。\\n 匹配换行键。\\r 匹配回车键。\\t 匹配制表符 tab（U+0009）。\\v 匹配垂直制表符（U+000B）。\\f 匹配换页符（U+000C）。\\0 匹配null字符（U+0000）。\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。 预定义模式预定义模式指的是某些常见模式的简写方式。 \\d 匹配0-9之间的任一数字，相当于[0-9]。\\D 匹配所有0-9以外的字符，相当于[^0-9]。\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。\\b 匹配词的边界。\\B 匹配非词边界，即在词的内部。 量词符 ? 问号表示某个模式出现0次或1次，等同于{0, 1} 星号表示某个模式出现0次或多次，等同于{0,} 加号表示某个模式出现1次或多次，等同于{1,} 1234567891011121314// t 出现0次或1次/t?est/.test(&apos;test&apos;) // true/t?est/.test(&apos;est&apos;) // true// t 出现1次或多次/t+est/.test(&apos;test&apos;) // true/t+est/.test(&apos;ttest&apos;) // true/t+est/.test(&apos;est&apos;) // false// t 出现0次或多次/t*est/.test(&apos;test&apos;) // true/t*est/.test(&apos;ttest&apos;) // true/t*est/.test(&apos;tttest&apos;) // true/t*est/.test(&apos;est&apos;) // true new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。将这个空对象的原型，指向构造函数的prototype属性。将这个空对象赋值给函数内部的this关键字。开始执行构造函数内部的代码。 object.create()构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。123456789101112var person1 = &#123; name: &apos;张三&apos;, age: 38, greeting: function() &#123; console.log(&apos;Hi! I\\&apos;m &apos; + this.name + &apos;.&apos;); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I&apos;m 张三. 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法 this主要有以下几个使用场合全局环境 . 全局环境使用this，它指的就是顶层对象window 123456this === window // truefunction f() &#123; console.log(this === window);&#125;f() // true 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window . 构造函数构造函数中的this，指的是实例对象 123456789var Obj = function (p) &#123; this.p = p;&#125;;``` - 对象的方法如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向#### Function.prototype.call() 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 var obj = {}; var f = function () { return this;}; f() === window // truef.call(obj) === obj // true1==call方法的一个应用是调用对象的原生方法== var obj = {};obj.hasOwnProperty(‘toString’) // false // 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () { return true;};obj.hasOwnProperty(‘toString’) // true Object.prototype.hasOwnProperty.call(obj, ‘toString’) // false123上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果#### Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 func.apply(thisValue, [arg1, arg2, …])1apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 function f(x, y){ console.log(x + y);} f.call(null, 1, 1) // 2f.apply(null, [1, 1]) // 21234上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数（1）找出数组最大元素JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。 var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15123（2）将数组的空元素变为undefined通过apply方法，利用Array构造函数将数组的空元素变成undefined。 Array.apply(null, [‘a’, ,’b’])// [ ‘a’, undefined, ‘b’ ]1空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 var a = [‘a’, , ‘b’]; function print(i) { console.log(i);} a.forEach(print)// a// b Array.apply(null, a).forEach(print)// a// undefined// b12==（3）转换类似数组的对象==，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 Array.prototype.slice.apply({0: 1, length: 1}) // [1]Array.prototype.slice.apply({0: 1}) // []Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]Array.prototype.slice.apply({length: 1}) // [undefined]123上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，==被处理的对象必须有length属性，以及相对应的数字键==（4）绑定回调函数的对象 var o = new Object(); o.f = function () { console.log(this === o);} var f = function (){ o.f.apply(o); // 或者 o.f.call(o);}; // jQuery 的写法$(‘#button’).on(‘click’, f);123上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法#### Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 var d = new Date();d.getTime() // 1481869925657 var print = d.getTime;print() //12上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了bind方法可以解决这个问题 var print = d.getTime.bind(d);print()123上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。 var counter = { count: 0, inc: function () { this.count++; }}; var func = counter.inc.bind(counter);func();counter.count // 1123上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。this绑定到其他对象也是可以的 var counter = { count: 0, inc: function () { this.count++; }}; var obj = { count: 100};var func = counter.inc.bind(obj);func();obj.count // 1011234567891011上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性**如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）**（1）每一次返回一个新函数bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样（2）结合回调函数使用回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。 var obj = { name: ‘张三’, times: [1, 2, 3], print: function () { this.times.forEach(function (n) { console.log(this.name); }); }}; obj.print()12// 没有任何输出上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。 obj.print = function () { this.times.forEach(function (n) { console.log(this === window); });}; obj.print()// true// true// true解决这个问题，也是通过bind方法绑定this。 obj.print = function () { this.times.forEach(function (n) { console.log(this.name); }.bind(this));}; obj.print()// 张三// 张三// 张三123（3）结合call方法使用利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例 [1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]1call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写 var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1]1234567891011121314151617上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法#### prototype 属性的作用原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系#### 原型链js规定 所有的对象都有一个自己的原型对象，一方面，任何一个对象都可以当着其他对象的原型对象，另一方面，原型对象它本身也是一个对象，所有它也有自己的原型，因此 就会形成一个原型链#### 构造函数的继承第一步是在子类的构造函数中，调用父类的构造函数第二步是让子类的原型指向父类的原型，这样子类就可以继承父类原型#### 单线程模型挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）#### setTimeout(f, 0)setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f, 0)，那么会立刻执行吗？答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行 setTimeout(function () { console.log(1);}, 0);console.log(2);// 2// 112#### Promise 构造函数JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例 var promise = new Promise(function (resolve, reject) { // … if (/ 异步操作成功 /){ resolve(value); } else { / 异步操作失败 / reject(new Error()); }});`上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。 ==resolve 函数的作用是==：将Promise实例的状态从==未完成==到==成功==，在异步操作成功的时候调用，并将异步操作的结果作为参数传递出去 ==rejected函数的作用是==：将Promise实例的状态从==未完成==到==失败==在异步操作失败的时候调用，并将异步操作爆出的错误作为参数传递出去 Event.preventDefault()CookieCookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息 Cookie 主要用来分辨两个请求是否来自同一个浏览器，以及用来保存一些状态信息。它的常用场合有以下一些。 对话（session）管理：保存登录、购物车等需要记录的信息。个性化：保存用户的偏好，比如网页的字体大小、背景色等等。追踪：记录和分析用户行为 Cookie 包含以下几方面的信息。 Cookie 的名字 Cookie 的值（真正的数据写在这里面） 到期时间 所属域名（默认是当前域名） 生效的路径（默认是当前网址） AJAXAJAX 包括以下几个步骤。 创建 XMLHttpRequest 实例 发出 HTTP 请求 接收服务器传回的数据 更新网页数据","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"vue日记28","slug":"vue日记28","date":"2019-07-10T14:42:29.000Z","updated":"2019-07-14T15:48:31.744Z","comments":true,"path":"2019/07/10/vue日记28/","link":"","permalink":"http://www.hefang.site/2019/07/10/vue日记28/","excerpt":"","text":"vue上手笔记第一个 vue 实例123456789101112131415161718&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, // 挂载到id为app的dom元素上 data: &#123; apple: &apos;apple&apos;, count: 0, &#125;, mounted: &#123; // this 指向 vue 实例 console.log(this.apple) &#125;, beforeDestory: &#123; &#125; &#125;) app.#el // 访问 vue 实例的el属性 app.apple // 访问 vue 实例的 apple 属性&lt;/script&gt; chap2 过滤器、指令和事件语法糖 过滤器 管道符 | 过滤器串联： | filter1(arg1, arg2) | filter2.. 指令 v-text: 渲染文本 v-html: 渲染html v-bind: 动态绑定属性 v-on: 监听 DOM 事件 事件语法糖 v-bind 的语法糖 : v-on 的语法糖 @ chap3 计算属性 何时用？ 文本插值可以写一行表达式，但是如果需要大量计算的时候，一行表达式放不下或者写法丑陋，这时应该利用计算属性。 12345678910data:&#123; firstname: &apos;san&apos;, lastname: &apos;zhang&apos;, text: &apos;123,456,789&apos;,&#125;,computed: &#123; reverseText:function()&#123; return this.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;) &#125;&#125; 小技巧 i. 计算属性可以依赖其他计算属性 ii. 计算属性可以依赖多个 vue 实例的数据 getter 和 setter 1234567891011121314151617computed: &#123; // 默认 getter 写法 reverseText: function()&#123; return this.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;) + &apos; / &apos; + app2.msg &#125;, // 重写 get,set 方法 fullName: &#123; get: function()&#123; return this.firstname + &apos; , &apos; + this.lastname &#125;, set: function(newName)&#123; console.log(&apos;set fullName 被调用了&apos;) this.firstname = newName.split(&apos;,&apos;)[0] this.lastname = newName.split(&apos;,&apos;)[1] &#125; &#125; &#125; 缓存问题 所有能用计算属性得到的数据，都可以用 methods 来做，计算属性和 methods 的重要区别是：计算属性是有缓存的。比如页面上 是计算属性，只要 fullname 相关的数据不更新，计算属性就不会更新，不需要重新渲染页面。如果是 getFullname 方法，当 data 中的其他数据更新，造成页面重新渲染的时候，那么 getFullname 也会重新执行。 12345678910111213141516// 当 count 渲染在页面上，并且更新的时候导致页面的重新渲染，这时 getFullname 方法也会再次执行，但是计算属性的 fullname 因为有缓存，只有用到的数据更新了才会更新data: &#123; this.firstname: &apos;san&apos;, this.lastname: &apos;zhang&apos;, this.count: 0,&#125;,methods: &#123; getFullname: function()&#123; return this.firstname + this.lastname &#125;&#125;,computed: &#123; fullname: function()&#123; return this.firstname + this.lastname &#125;&#125; chap4 v-bind 绑定 class 变量语法 v-bind:class=&#39;classVariable&#39; data:{ classVariable: &#39;some-class-name&#39;} 对象语法 v-bind:class={class1: boolean1, class2: boolean2} 123456789&lt;div v-bind:class=&apos;&#123;background: isback, border: isborder&#125;&apos;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isback: true, isborder: true, &#125;&#125;) 当逻辑复杂的时候可以用计算属性返回对象 数组语法 v-bind:class=[class1, class2, &#39;class3&#39;] 数组和对象混用 v-bind:class=[{&#39;active&#39;: isActive} ,&#39;error&#39;] chap4 v-bind 绑定 style，内联样式 对象语法 v-bind:style=&quot;{&#39;color&#39;: color, &#39;fontSize&#39;: fontSize+&#39;px&#39;}&quot; 属性要用驼峰命名 1234data: &#123; color: &apos;red&apos;, fontSize: 16,&#125; 数组语法(用的不多) chap5 vue 的内置指令 v-cloak 解决初始化慢导致页面闪动，常用 display:none 结合使用 v-once 元素只渲染一次 条件渲染. v-if v-else v-else-if v-show v-if 的弊端： 在渲染的时候会尽可能的复用已有的元素，只渲染变化的部分，因此可能会出现不想要的情况。为了不复用元素，可以给元素加key属性。 v-if 和 v-show 的比较: v-if 不满足条件的时候，dom 元素会被移除。v-show渲染之后 dom 元素会一直存在，如果不满足条件，是通过display:none隐藏的。 v-for 遍历数组对象 v-for=&#39;value in arr&#39; v-for=&#39;(value,index) in arr&#39; 遍历对象属性 v-for=&#39;value in obj&#39; v-for=&#39;(value, key, index) in obj&#39; vue 可以检测到的数组改变方法 pop push shift unshift splice sort reverse vue 检测不到的数组改变情况 修改数组指定项 arr[1] = &#39;text&#39;，改用 Vue.set(app.arr, 1, &#39;text&#39;) 修改数组长度 arr.length = 10 事件 .stop 阻止进一步冒泡 .prevent 阻止默认事件 .self 事件发生是自己 (target === currentTarget) once 事件只执行一次 绑定事件监听的时候，不加括号的话传递的第一个参数是原生事件对象 event &lt;button @click=&#39;handle&#39;&gt;click&lt;/button&gt; &lt;button @click=&#39;handle2(&quot;hello&quot;)&gt;click&lt;/button&gt; 12345678methods: &#123; handle: function(event)&#123; console.log(event) &#125;, handle2: function(str)&#123; console.log(str) // hello &#125;&#125; chap6 表单和 v-model v-model 用于在表单类元素上双向绑定，比如 input,textarea 等 &lt;textarea cols=&quot;30&quot; rows=&quot;10&quot; v-model=&#39;msg&#39;&gt;我是多行文本的初始化值&lt;/textarea&gt; 绑定了 v-model 会忽略 textarea 的默认值 单选框 单个单选框用 v-bind 绑定属性(v-model 不生效) 多个单选框用 v-model 和 value 配合使用 复选框 单个复选框：用 v-bind 和 v-model 绑定都可以 多个复选框：用 v-model 和 value 配合使用。当 v-model 的初始值是字符串的时候，选中后绑定值会变成 true,如果初始值是数组，选中后绑定值会增加对应的 value 下拉框 单选下拉框：用 v-model 双向绑定时，初始化可以是字符串也可以是数组，选中后绑定值为对应的 value。 多选下拉框：用 v-model 双向绑定时，初始化可以是字符串也可以是数组，选中后绑定值对对应的 value 或者 value 的数组. 总结： 单个 radio 用 v-bind，v-model 是不生效的 多选时（checkbox, select)，v-model 最好初始化为数组 单选 v-model 最好初始化为字符串 动态绑定： 用 v-bind 绑定值后，可以用 v-model获取绑定值(但是有必要吗？) true-value 和 false-value 动态绑定不同的值 在 select 标签上绑定 value 属性对 option 没有影响 修饰符: v-model.lazy 失去焦点或者敲回车之后改变v-model的值(默认的是input事件实时更新) v-model.number 自动将可转换的 string 变为 number v-model.trim 去掉首尾空格 chap7 组件 7-1 组件的注册和挂载 全局注册组件 123456Vue.component(&apos;my-component&apos;,&#123; template: &apos;&lt;div&gt;组件&lt;/div&gt;&apos;&#125;)&lt;div id=&apos;app&apos;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 优点：所有的 vue 实例都可以使用. 缺点：权限太大，容错率降低。 局部注册组件 12345678var app = new Vue(&#123; el: &apos;#app&apos;, components: &#123; &apos;app-component&apos;: &#123; template: &apos;&lt;div&gt;app内局部注册的组件&lt;/div&gt;&apos; &#125; &#125;&#125;) is属性挂载组件 组件的使用会受到html标签的限制，比如 &lt;table&gt;标签内只能有&lt;tr&gt;`,所以直接在中挂载组件没有用。这时可以用is`属性来挂载组件. 123&lt;table&gt; &lt;tbody is=&apos;my-component&apos;&gt;&lt;/table&gt; 组件的注意事项 命名必须小写加横线（xxx,xxx-component) template 的内容必须被一个 DOM 元素包裹(可以嵌套) 除了 template 外，可以定义组件的其他属性（data, methods, computed) data 必须是一个方法(函数) 7-2 props 传递消息 i. 子组件通过 props 属性来接收父组件传递的值 props: [&#39;msg&#39;] ii. props 值有两种，一种是字符串数组，一种是对象 iii. props 和 data 都是属于子组件的作用域，里面的变量可以在 template, computed, methods 中使用 iv. 传递给子组件的属性值可以通过 v-bind 动态绑定 v. v-bind 动态绑定的细小区别 123v-bind:msg=&apos;[aaa,bbb,ccc]&apos; // 子组件认为 msg 是一个数组对象，长度是 3msg=&apos;[aaa,bbb,ccc]&apos; // 子组件认为 msg 是一个完整的字符串，长度是13 7-3 props 和单项数据流 两种应用场景： i. props 接收父组件传递过来的数据，并作为初始值保存起来 ii. props 接收父组件传递过来的数据并转换保存起来（利用计算属性） 7-4 数据验证 驼峰命名 V.S. 短横线命名 a. 在 html 中 component 或者属性只能用小写加短横线命名(绝对不允许驼峰) b. 在组件的 template 中使用驼峰 c. 在组件的 data 中使用 this.xxx 只能使用驼峰 对 props 传递进来的属性进行类型验证, props 写成对象 1234567891011props: &#123; c: &#123; type: Boolean, required: true, default: false, validator: function(value)&#123; // 自定义验证 return true &#125;, &#125;&#125; 7-5 自定义事件-子组件给父组件传递数据 $emit() 触发事件 $on() 监听事件 7-6 在组件中使用 v-model 7-7 非父子组件的通信：父链、子链 this.$root.bus.$emit() &amp; this.$root.bus.$on() a. 中央事件总线 bus = new Vue() 父链 this.$parent 子链 this.$refs.x （给子组件设置 ref 属性) 7-8 组件作用域 7-9 使用 slot 分发内容 i. slot： 混合父子组件的内容，弥补视图不足 ii. 单个 slot 和具名 slot 7-10 作用域 slot（从子组件获取数据） i. vue 2.5.0 之前要写在 template 标签之中 ii. vue 2.5.0 之后可以写在其他 html 标签中 iii. template 标签本身不会被渲染的 1234&lt;template slot=&apos;xxx&apos; slot-scope=&apos;prop&apos;&gt; &#123;&#123; prop.text &#125;&#125; &lt;br&gt; &#123;&#123; prop.ss &#125;&#125; &lt;/template&gt; 7-11 访问 slot a. this.$slots.xxx 7-12 组件的高级用法 内联模板(待学) 异步组件(待学) 动态组件 vue 提供了component 元素 （通过is 属性实现） &lt;component :is=&quot;xxx&quot;&gt;&lt;/component&gt; :is 是动态绑定的，注意冒号! chap8 自定义指令&lt;div v-mydirectives:testarg.a.b.c=&#39;testvalue&#39;&gt;&lt;/div&gt; 指令的钩子函数 bind 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新 componentUpdated 被绑定元素所在模板完成一次更新周期时调用 unbind 只调用一次， 指令与元素解绑时调用 钩子函数的参数 el 指令所绑定的元素，可以直接用来操作 DOM binding：一个对象，包含如下属性 name 指令名，不包括 v- 前缀 value 指定的绑定值，比如mydirective=&#39;test&#39;，test就是value值 oldValue 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用 expression 绑定值的字符串形式。 例如 v­my­directive=&#39;1 + 1&#39; ， expression 的值是1 + 1。 arg 传给指令的参数,比如mydirective:apple，apple就是参数 modifiers 修饰符对象,比如mydirective:apple.a.b.c，modifiers就是{a:true,b:true,c:true} 3. vnode Vue 编译生成的虚拟节点 4. oldVnode 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用 chap9 render 函数 render 函数参数 render: function(createElement) createElement 参数分析 第一个参数 a. createElement(&#39;h&#39;) 可以是 html 的 tag 标签 b. `createElement({ template: &apos;&lt;div&gt;hello world&lt;/div&gt;&apos; })` 可以是数据对象，有 template 属性 c. `createElement(()=&gt;{ return { template: &apos;&lt;div&gt;hello world&lt;/div&gt;&apos; } })` 可以是函数，返回数据对象，有 template 属性 第二个参数，设置属性 12345678910111213141516171819202122232425262728createElement(&apos;div&apos;,&#123; // class class: &#123; foo: true, bar: false &#125;, // style style: &#123; color: &apos;red&apos;, fontSize: &apos;16px&apos;, // 注意驼峰 &#125;, // 常用 html 属性 或者自定义属性 attrs: &#123; id: &apos;xxx&apos;, src: &apos;yyy&apos;, hhh: &apos;hahaha&apos; &#125;, // 原生 DOM 属性 domProps: &#123; value: &apos;hello world&apos; &#125;, // 事件监听 on: &#123; click: function(event)&#123; console.log(event.target.value) &#125; &#125;&#125;) 第三个参数，string 或者 Vnode的数组，表示子节点 12345678910createElement(&apos;h1&apos;,&apos;我是标题的内容&apos;)createElement(&apos;ul&apos;,[ createElement(&apos;li&apos;,&#123; style: &#123; color: &apos;red&apos; &#125; &#125;,&apos;我是第一项&apos;), createElement(&apos;li&apos;,&apos;我是第二项&apos;), createElement(&apos;li&apos;,&apos;我是第三项&apos;),]) render 函数中 使用 slots props 和 v-model 作用域插槽 scopedSlots chap10 函数化组件functional: true1234render: function(createElement, context)&#123; // context.props return createElement(&apos;h1&apos;,&apos;nice~&apos;)&#125; chap11 vue-cli 脚手架12npm install -g vue-cli // 全局安装 vue-clivue init webpack xxx-project // 用模版初始化项目 目录结构分析 build 项目构建(webpack) 相关 build.js 生产环境构建代码 check-version.js 检查 node &amp; npm 等版本 dev-client.js 热加载相关 dev-server.js 构建本地服务器 utils.js 构建配置公用工具 vue-loader.conf.js vue 加载器 chap12 vue-router下载npm install --save vue-router 引用和配置路由123456789101112131415161718import router from &apos;vue-router&apos;import HelloWorld from &apos;./HelloWorld.vue&apos;Vue.use(router)var router = new router(&#123; routes: [&#123; path: &apos;/&apos;, // name: &apos;HelloWorld&apos;, component: HelloWorld &#125;]&#125;)new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App, &#125;, template: &apos;&lt;App /&gt;&apos;&#125;) 视图加载的位置&lt;router-view&gt;&lt;/router-view&gt; 跳转&lt;router-link to=&quot;/&quot;&gt;回到首页&lt;/router-link&gt; 路由传递参数123&lt;router-link :to=&quot;&#123;name: helloWorld, params:&#123;msg: &apos;我是params&apos;&#125;&#125;&quot;&gt;跳转1&lt;/router-link&gt;&lt;router-link :to=&quot;&#123;path: &apos;/&apos;, query:&#123;msg: &apos;我是query&apos;&#125;&#125;&quot;&gt;跳转2&lt;/router-link&gt; chap13 axios 简单入门安装npm install axios 引用import axios from &#39;axios&#39; 挂载到Vue原型上Vue.prototype.$http = axios 请求示例12345678910import qs from &apos;qs&apos;this.$http.get(url, &#123; params: &#123; id: 111, &#125;&#125;)this.$http.post(url, qs.stringify(&#123; id: 111,&#125;)) post 传递数据有两种格式： from-data ?page=1&amp;limit=10 x-www-form-urlencoded { page: 1, limit: 10 } 在 axios 中，post 请求接收的参数必须是 form-data，用 qs 插件, qs.stringify chap14 vuex 状态管理vuex，类似 redux 的状态管理工具 view —&gt; actions —&gt; mutations —&gt; state —&gt; view 安装npm install vuex 引用123456789101112131415161718192021222324252627282930import Vuex from &apos;vuex&apos;var store = new Vuex.Store(&#123; // 注意大写 state: &#123; name: &apos;jack&apos;, count: 0, &#125;, mutations: &#123; add(state)&#123; state.count++ &#125; &#125;, actions: &#123; addActions(context)&#123; context.commit(&apos;add&apos;) &#125; &#125;, getters: &#123; getCount()&#123; return state.count &gt; 0 ? state.count : 0 &#125; &#125;&#125;)// 使用方法this.$store.state.countthis.$store.getters.getCountthis.$store.commit(&apos;add&apos;) // commit 的是 mutationsthis.$store.dispatch(&apos;addAction&apos;) // dispatch 的是 actions// actions 可以包含异步动作，mutations 只能包含同步动作","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记27","slug":"vue日记27","date":"2019-07-06T14:42:29.000Z","updated":"2019-07-13T13:42:09.024Z","comments":true,"path":"2019/07/06/vue日记27/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记27/","excerpt":"","text":"vue日记27深入响应式原理 现在是时候深入一下了！Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节 如何追踪变化当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染 检测变化的注意事项受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。例如，对于：1Vue.set(vm.someObject, &apos;b&apos;, 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：1this.$set(this.someObject,&apos;b&apos;,2) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值：123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message`vm.message = &apos;Hello!&apos; 如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的属性。 这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作。但与此同时在代码可维护性方面也有一点重要的考虑：data 对象就像组件状态的结构 (schema)。提前声明所有的响应式属性，可以让组件代码在未来修改或给其他开发人员阅读时更易于理解 异步更新队列可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。例如：12345678910111213&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;123&apos; &#125;&#125;)vm.message = &apos;new message&apos; // 更改数据vm.$el.textContent === &apos;new message&apos; // falseVue.nextTick(function () &#123; vm.$el.textContent === &apos;new message&apos; // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;未更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;已更新&apos; console.log(this.$el.textContent) // =&gt; &apos;未更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;已更新&apos; &#125;) &#125; &#125;&#125;) 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：12345678methods: &#123; updateMessage: async function () &#123; this.message = &apos;已更新&apos; console.log(this.$el.textContent) // =&gt; &apos;未更新&apos; await this.$nextTick() console.log(this.$el.textContent) // =&gt; &apos;已更新&apos; &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记26","slug":"vue日记26","date":"2019-07-06T13:42:29.000Z","updated":"2019-07-13T13:41:01.956Z","comments":true,"path":"2019/07/06/vue日记26/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记26/","excerpt":"","text":"vue日记26状态管理类 Flux 状态管理的官方实现由于状态零散地分布在许多组件和组件之间的交互中，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 vuex：我们有受到 Elm 启发的状态管理库。vuex 甚至集成到 vue-devtools，无需配置即可进行时光旅行调试 (time travel debugging)。 简单状态管理起步使用经常被忽略的是，Vue 应用中原始数据对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享123456789const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 现在当 sourceOfTruth 发生变化，vmA 和 vmB 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。现在我们有了唯一的数据来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录 为了解决这个问题，我们采用一个简单的==store== 模式：1234567891011121314var store = &#123; debug: true, state: &#123; message: &apos;Hello!&apos; &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log(&apos;setMessageAction triggered with&apos;, newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log(&apos;clearMessageAction triggered&apos;) this.state.message = &apos;&apos; &#125;&#125; 需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么 此外，每个实例/组件仍然可以拥有和管理自己的私有状态：12345678910111213var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) ==重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察== 接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记25","slug":"vue日记25","date":"2019-07-06T13:41:29.000Z","updated":"2019-07-13T13:39:36.858Z","comments":true,"path":"2019/07/06/vue日记25/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记25/","excerpt":"","text":"vue日记25路由官方路由 从零开始简单的路由如果你只需要非常简单的路由而不想引入一个功能完整的路由库，可以像这样动态渲染一个页面级的组件：123456789101112131415161718192021const NotFound = &#123; template: &apos;&lt;p&gt;Page not found&lt;/p&gt;&apos; &#125;const Home = &#123; template: &apos;&lt;p&gt;home page&lt;/p&gt;&apos; &#125;const About = &#123; template: &apos;&lt;p&gt;about page&lt;/p&gt;&apos; &#125;const routes = &#123; &apos;/&apos;: Home, &apos;/about&apos;: About&#125;new Vue(&#123; el: &apos;#app&apos;, data: &#123; currentRoute: window.location.pathname &#125;, computed: &#123; ViewComponent () &#123; return routes[this.currentRoute] || NotFound &#125; &#125;, render (h) &#123; return h(this.ViewComponent) &#125;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记24","slug":"vue日记24","date":"2019-07-06T12:41:29.000Z","updated":"2019-07-13T13:38:32.711Z","comments":true,"path":"2019/07/06/vue日记24/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记24/","excerpt":"","text":"vue日记24单元测试 Vue CLI 拥有开箱即用的通过 Jest 或 Mocha 进行单元测试的内置选项。我们还有官方的 Vue Test Utils 提供更多详细的指引和自定义设置 简单的断言你不必为了可测性在组件中做任何特殊的操作，导出原始设置就可以了：12345678910111213141516&lt;template&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; message: &apos;hello!&apos; &#125; &#125;, created () &#123; this.message = &apos;bye!&apos; &#125; &#125;&lt;/script&gt; 然后随着 Vue 导入组件的选项，你可以使用许多常见的断言 (这里我们使用的是 Jasmine/Jest 风格的 expect 断言作为示例)：1234567891011121314151617181920212223242526272829303132// 导入 Vue.js 和组件，进行测试import Vue from &apos;vue&apos;import MyComponent from &apos;path/to/MyComponent.vue&apos;// 这里是一些 Jasmine 2.0 的测试，你也可以使用你喜欢的任何断言库或测试工具。describe(&apos;MyComponent&apos;, () =&gt; &#123; // 检查原始组件选项 it(&apos;has a created hook&apos;, () =&gt; &#123; expect(typeof MyComponent.created).toBe(&apos;function&apos;) &#125;) // 评估原始组件选项中的函数的结果 it(&apos;sets the correct default data&apos;, () =&gt; &#123; expect(typeof MyComponent.data).toBe(&apos;function&apos;) const defaultData = MyComponent.data() expect(defaultData.message).toBe(&apos;hello!&apos;) &#125;) // 检查 mount 中的组件实例 it(&apos;correctly sets the message when created&apos;, () =&gt; &#123; const vm = new Vue(MyComponent).$mount() expect(vm.message).toBe(&apos;bye!&apos;) &#125;) // 创建一个实例并检查渲染输出 it(&apos;renders the correct message&apos;, () =&gt; &#123; const Constructor = Vue.extend(MyComponent) const vm = new Constructor().$mount() expect(vm.$el.textContent).toBe(&apos;bye!&apos;) &#125;)&#125;) 编写可被测试的组件很多组件的渲染输出由它的 props 决定。事实上，如果一个组件的渲染输出完全取决于它的 props，那么它会让测试变得简单，就好像断言不同参数的纯函数的返回值。看下面这个例子：123456789&lt;template&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&apos;msg&apos;] &#125;&lt;/script&gt; 你可以在不同的 props 中，通过 propsData 选项断言它的渲染输出：123456789101112131415161718192021import Vue from &apos;vue&apos;import MyComponent from &apos;./MyComponent.vue&apos;// 挂载元素并返回已渲染的文本的工具函数function getRenderedText (Component, propsData) &#123; const Constructor = Vue.extend(Component) const vm = new Constructor(&#123; propsData: propsData &#125;).$mount() return vm.$el.textContent&#125;describe(&apos;MyComponent&apos;, () =&gt; &#123; it(&apos;renders correctly with different props&apos;, () =&gt; &#123; expect(getRenderedText(MyComponent, &#123; msg: &apos;Hello&apos; &#125;)).toBe(&apos;Hello&apos;) expect(getRenderedText(MyComponent, &#123; msg: &apos;Bye&apos; &#125;)).toBe(&apos;Bye&apos;) &#125;)&#125;) 断言异步更新由于 Vue 进行 异步更新 DOM 的情况，一些依赖 DOM 更新结果的断言必须在 Vue.nextTick 回调中进行：1234567891011// 在状态更新后检查生成的 HTMLit(&apos;updates the rendered message when vm.message updates&apos;, done =&gt; &#123; const vm = new Vue(MyComponent).$mount() vm.message = &apos;foo&apos; // 在状态改变后和断言 DOM 更新前等待一刻 Vue.nextTick(() =&gt; &#123; expect(vm.$el.textContent).toBe(&apos;foo&apos;) done() &#125;)&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记23","slug":"vue日记23","date":"2019-07-06T12:40:29.000Z","updated":"2019-07-13T13:36:27.116Z","comments":true,"path":"2019/07/06/vue日记23/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记23/","excerpt":"","text":"vue日记23单文件组件介绍 在很多 Vue 项目中，我们使用 Vue.component 来定义全局组件，紧接着用 new Vue({ el: ‘#container ‘}) 在每个页面内指定一个容器元素。 这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显： 全局定义 (Global definitions) 强制要求每个 component 中的命名不得重复 字符串模板 (String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \\ 不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏 没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel 文件扩展名为 .vue 的 single-file components(单文件组件) 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具 这是一个文件名为 Hello.vue 的简单实例： 现在我们获得： 完整语法高亮 CommonJS 模块 组件作用域的 CSS 正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Pug，Babel (with ES2015 modules)，和 Stylus这些特定的语言只是例子，你可以只是简单地使用 Babel，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。如果搭配 vue-loader 使用 webpack，它也能为 CSS Modules 提供头等支持 怎么看待关注点分离？一个重要的事情值得注意，关注点分离不等于文件类型分离。在现代 UI 开发中，我们已经发现相比于把代码库分离成三个大的层次并将其相互交织起来，把它们划分为松散耦合的组件再将其组合起来更合理一些。在一个组件里，其模板、逻辑和样式是内部耦合的，并且把他们搭配在一起实际上使得组件更加内聚且更可维护 即便你不喜欢单文件组件，你仍然可以把 JavaScript、CSS 分离成独立的文件然后做到热重载和预编译。123456&lt;!-- my-component.vue --&gt;&lt;template&gt; &lt;div&gt;This will be pre-compiled&lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;./my-component.js&quot;&gt;&lt;/script&gt;&lt;style src=&quot;./my-component.css&quot;&gt;&lt;/style&gt; 针对刚接触 JavaScript 模块开发系统的用户有了 .vue 组件，我们就进入了高级 JavaScript 应用领域。如果你没有准备好的话，意味着还需要学会使用一些附加的工具： Node Package Manager (NPM)：阅读 Getting Started guide 直到 10: Uninstalling global packages章节。 Modern JavaScript with ES2015/16：阅读 Babel 的 Learn ES2015 guide。你不需要立刻记住每一个方法，但是你可以保留这个页面以便后期参考 针对高级用户CLI 会为你搞定大多数工具的配置问题，同时也支持细粒度自定义配置项。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记22","slug":"vue日记22","date":"2019-07-06T12:39:29.000Z","updated":"2019-07-13T13:32:41.473Z","comments":true,"path":"2019/07/06/vue日记22/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记22/","excerpt":"","text":"vue日记22过滤器 Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 你可以在一个组件的选项中定义本地的过滤器：1234567filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 或者在创建 Vue 实例之前全局定义过滤器：123456789Vue.filter(&apos;capitalize&apos;, function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; // ...&#125;) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数 过滤器可以串联：1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中 过滤器是 JavaScript 函数，因此可以接收参数：1&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125; 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记21","slug":"vue日记21","date":"2019-07-06T12:36:29.000Z","updated":"2019-07-13T13:30:46.081Z","comments":true,"path":"2019/07/06/vue日记21/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记21/","excerpt":"","text":"vue日记21插件 插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者属性。如: vue-custom-element 添加全局资源：指令/过滤器/过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成：123456// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)new Vue(&#123; // ...组件选项&#125;) 也可以传入一个可选的选项对象：1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use()：123456// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时var Vue = require(&apos;vue&apos;)var VueRouter = require(&apos;vue-router&apos;)// 不要忘了调用此方法Vue.use(VueRouter) 开发插件Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记20","slug":"vue日记20","date":"2019-07-06T12:33:29.000Z","updated":"2019-07-13T13:29:26.381Z","comments":true,"path":"2019/07/06/vue日记20/","link":"","permalink":"http://www.hefang.site/2019/07/06/vue日记20/","excerpt":"","text":"vue日记20渲染函数 &amp; JSX基础使用 render 函数1234567891011121314Vue.component(&apos;anchored-heading&apos;, &#123; render: function (createElement) &#123; return createElement( &apos;h&apos; + this.level, // 标签名称 this.$slots.default // 子节点数组 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 节点、树以及虚拟 DOM当浏览器读到这些代码时，它会建立一个“DOM 节点”树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。 上述 HTML 对应的 DOM 节点树如下图所示：每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。 高效地更新所有这些节点会是比较困难的，不过所幸你不必手动完成这个工作。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：1&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt; 或者一个渲染函数里：123render: function (createElement) &#123; return createElement(&apos;h1&apos;, this.blogTitle)&#125; 在这两种情况下，Vue 都会自动保持页面的更新，即便 blogTitle 发生了改变。 虚拟 DOMVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码:1return createElement(&apos;h1&apos;, this.blogTitle) createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼 createElement 参数接下来你需要熟悉的是如何在 createElement 函数中使用模板中的那些功能。这里是 createElement 接受的参数：1234567891011121314151617181920212223242526// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // 一个 HTML 标签名、组件选项对象，或者 // resolve 了上述任何一种的一个 async 函数。必填项。 &apos;div&apos;, // &#123;Object&#125; // 一个与模板中属性对应的数据对象。可选。 &#123; // (详情见下一节) &#125;, // &#123;String | Array&#125; // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选。 [ &apos;先写一些文字&apos;, createElement(&apos;h1&apos;, &apos;一则头条&apos;), createElement(MyComponent, &#123; props: &#123; someProp: &apos;foobar&apos; &#125; &#125;) ]) 深入数据对象有一点要注意：正如 v-bind:class 和 v-bind:style 在模板语法中会被特别对待一样，它们在 VNode 数据对象中也有对应的顶层字段。该对象也允许你绑定普通的 HTML 特性，也允许绑定如 innerHTML 这样的 DOM 属性 (这会覆盖 v-html 指令)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; // 与 `v-bind:class` 的 API 相同， // 接受一个字符串、对象或字符串和对象组成的数组 &apos;class&apos;: &#123; foo: true, bar: false &#125;, // 与 `v-bind:style` 的 API 相同， // 接受一个字符串、对象，或对象组成的数组 style: &#123; color: &apos;red&apos;, fontSize: &apos;14px&apos; &#125;, // 普通的 HTML 特性 attrs: &#123; id: &apos;foo&apos; &#125;, // 组件 prop props: &#123; myProp: &apos;bar&apos; &#125;, // DOM 属性 domProps: &#123; innerHTML: &apos;baz&apos; &#125;, // 事件监听器在 `on` 属性内， // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中手动检查 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: &apos;my-custom-directive&apos;, value: &apos;2&apos;, expression: &apos;1 + 1&apos;, arg: &apos;foo&apos;, modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽的格式为 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement(&apos;span&apos;, props.text) &#125;, // 如果组件是其它组件的子组件，需为插槽指定名称 slot: &apos;name-of-slot&apos;, // 其它特殊顶层属性 key: &apos;myKey&apos;, ref: &apos;myRef&apos;, // 如果你在渲染函数中给多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 完整示例1234567891011121314151617181920212223242526272829303132333435var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join(&apos;&apos;)&#125;Vue.component(&apos;anchored-heading&apos;, &#123; render: function (createElement) &#123; // 创建 kebab-case 风格的 ID var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, &apos;-&apos;) .replace(/(^-|-$)/g, &apos;&apos;) return createElement( &apos;h&apos; + this.level, [ createElement(&apos;a&apos;, &#123; attrs: &#123; name: headingId, href: &apos;#&apos; + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 约束VNode 必须唯一组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：1234567render: function (createElement) &#123; var myParagraphVNode = createElement(&apos;p&apos;, &apos;hi&apos;) return createElement(&apos;div&apos;, [ // 错误 - 重复的 VNode myParagraphVNode, myParagraphVNode ])&#125; 如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这渲染函数用完全合法的方式渲染了 20 个相同的段落：1234567render: function (createElement) &#123; return createElement(&apos;div&apos;, Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement(&apos;p&apos;, &apos;hi&apos;) &#125;) )&#125; 使用 JavaScript 代替模板功能v-if 和 v-for只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。比如，在模板中使用的 v-if 和 v-for：1234&lt;ul v-if=&quot;items.length&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 这些都可以在渲染函数中用 JavaScript 的 if/else 和 map 来重写：12345678910props: [&apos;items&apos;],render: function (createElement) &#123; if (this.items.length) &#123; return createElement(&apos;ul&apos;, this.items.map(function (item) &#123; return createElement(&apos;li&apos;, item.name) &#125;)) &#125; else &#123; return createElement(&apos;p&apos;, &apos;No items found.&apos;) &#125;&#125; v-model渲染函数中没有与 v-model 的直接对应——你必须自己实现相应的逻辑：1234567891011121314props: [&apos;value&apos;],render: function (createElement) &#123; var self = this return createElement(&apos;input&apos;, &#123; domProps: &#123; value: self.value &#125;, on: &#123; input: function (event) &#123; self.$emit(&apos;input&apos;, event.target.value) &#125; &#125; &#125;)&#125; 事件 &amp; 按键修饰符对于 .passive、.capture 和 .once 这些事件修饰符, Vue 提供了相应的前缀可以用于 on： 修饰符 前缀.passive &amp;.capture !.once ~.capture.once 或.once.capture ~!例如:12345on: &#123; &apos;!click&apos;: this.doThisInCapturingMode, &apos;~keyup&apos;: this.doThisOnce, &apos;~!mouseover&apos;: this.doThisOnceInCapturingMode&#125; 对于所有其它的修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法：12345678910111213141516on: &#123; keyup: function (event) &#123; // 如果触发事件的元素不是事件绑定的元素 // 则返回 if (event.target !== event.currentTarget) return // 如果按下去的不是 enter 键或者 // 没有同时按下 shift 键 // 则返回 if (!event.shiftKey || event.keyCode !== 13) return // 阻止 事件冒泡 event.stopPropagation() // 阻止该元素默认的 keyup 事件 event.preventDefault() // ... &#125;&#125; 插槽你可以通过 this.$slots 访问静态插槽的内容，每个插槽都是一个 VNode 数组：1234render: function (createElement) &#123; // `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement(&apos;div&apos;, this.$slots.default)&#125; 也可以通过 this.$scopedSlots 访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数：123456789props: [&apos;message&apos;],render: function (createElement) &#123; // `&lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement(&apos;div&apos;, [ this.$scopedSlots.default(&#123; text: this.message &#125;) ])&#125; 如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据对象中的 scopedSlots 字段：12345678910111213render: function (createElement) &#123; return createElement(&apos;div&apos;, [ createElement(&apos;child&apos;, &#123; // 在数据对象中传递 `scopedSlots` // 格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement(&apos;span&apos;, props.text) &#125; &#125; &#125;) ])&#125; JSX如果你写了很多 render 函数，可能会觉得下面这样的代码写起来很痛苦：12345678910createElement( &apos;anchored-heading&apos;, &#123; props: &#123; level: 1 &#125; &#125;, [ createElement(&apos;span&apos;, &apos;Hello&apos;), &apos; world!&apos; ]) 特别是对应的模板如此简单的情况下：123&lt;anchored-heading :level=&quot;1&quot;&gt; &lt;span&gt;Hello&lt;/span&gt; world!&lt;/anchored-heading&gt; 这就是为什么会有一个 Babel 插件，用于在 Vue 中使用 JSX 语法，它可以让我们回到更接近于模板的语法上123456789101112import AnchoredHeading from &apos;./AnchoredHeading.vue&apos;new Vue(&#123; el: &apos;#demo&apos;, render: function (h) &#123; return ( &lt;AnchoredHeading level=&#123;1&#125;&gt; &lt;span&gt;Hello&lt;/span&gt; world! &lt;/AnchoredHeading&gt; ) &#125;&#125;) 将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的。从 Vue 的 Babel 插件的 3.4.0 版本开始，我们会在以 ES2015 语法声明的含有 JSX 的任何方法和 getter 中 (不是函数或箭头函数中) 自动注入 const h = this.$createElement，这样你就可以去掉 (h) 参数了。对于更早版本的插件，如果 h 在当前作用域中不可用，应用会抛错 函数式组件之前创建的锚点标题组件是比较简单，没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法。实际上，它只是一个接受一些 prop 的函数。在这样的场景下，我们可以将组件标记为 functional，这意味它无状态 (没有响应式数据)，也没有实例 (没有 this 上下文)。一个函数式组件就像这样：123456789101112Vue.component(&apos;my-component&apos;, &#123; functional: true, // Props 是可选的 props: &#123; // ... &#125;, // 为了弥补缺少的实例 // 提供第二个参数作为上下文 render: function (createElement, context) &#123; // ... &#125;&#125;) 组件需要的一切都是通过 context 参数传递，它是一个包括如下字段的对象 props：提供所有 prop 的对象 children: VNode 子节点的数组 slots: 一个函数，返回了包含所有插槽的对象 scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。 data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件 parent：对父组件的引用 listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。 injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。 在添加 functional: true 之后，需要更新我们的锚点标题组件的渲染函数，为其增加 context 参数，并将 this.$slots.default 更新为 context.children，然后将 this.level 更新为 context.props.level 因为函数式组件只是函数，所以渲染开销也低很多。 在作为包装组件时它们也同样非常有用。比如，当你需要做这些时： 程序化地在多个组件中选择一个来代为渲染； \u0010在将 children、props、data 传递给子组件之前操作它们。 1234567891011121314151617181920212223242526272829303132var EmptyList = &#123; /* ... */ &#125;var TableList = &#123; /* ... */ &#125;var OrderedList = &#123; /* ... */ &#125;var UnorderedList = &#123; /* ... */ &#125;Vue.component(&apos;smart-list&apos;, &#123; functional: true, props: &#123; items: &#123; type: Array, required: true &#125;, isOrdered: Boolean &#125;, render: function (createElement, context) &#123; function appropriateListComponent () &#123; var items = context.props.items if (items.length === 0) return EmptyList if (typeof items[0] === &apos;object&apos;) return TableList if (context.props.isOrdered) return OrderedList return UnorderedList &#125; return createElement( appropriateListComponent(), context.data, context.children ) &#125;&#125;) 向子元素或子组件传递特性和事件在普通组件中，没有被定义为 prop 的特性会自动添加到组件的根元素上，将已有的同名特性进行替换或与其进行智能合并然而函数式组件要求你显式定义该行为：1234567Vue.component(&apos;my-functional-button&apos;, &#123; functional: true, render: function (createElement, context) &#123; // 完全透传任何特性、事件监听器、子节点等。 return createElement(&apos;button&apos;, context.data, context.children) &#125;&#125;) 通过向 createElement 传入 context.data 作为第二个参数，我们就把 my-functional-button 上面所有的特性和事件监听器都传递下去了。事实上这是非常透明的，以至于那些事件甚至并不要求 .native 修饰符。 如果你使用基于模板的函数式组件，那么你还需要手动添加特性和监听器。因为我们可以访问到其独立的上下文内容，所以我们可以使用 data.attrs 传递任何 HTML 特性，也可以使用 listeners (即 data.on 的别名) 传递任何事件监听器。123456789&lt;template functional&gt; &lt;button class=&quot;btn btn-primary&quot; v-bind=&quot;data.attrs&quot; v-on=&quot;listeners&quot; &gt; &lt;slot/&gt; &lt;/button&gt;&lt;/template&gt; slots() 和 children 对比你可能想知道为什么同时需要 slots() 和 children。slots().default 不是和 children 类似的吗？在一些场景中，是这样——但如果是如下的带有子节点的函数式组件呢？123456&lt;my-functional-component&gt; &lt;p v-slot:foo&gt; first &lt;/p&gt; &lt;p&gt;second&lt;/p&gt;&lt;/my-functional-component&gt; 对于这个组件，children 会给你两个段落标签，而 slots().default 只会传递第二个匿名段落标签，slots().foo 会传递第一个具名段落标签。同时拥有 children 和 slots()，因此你可以选择让组件感知某个插槽机制，还是简单地通过传递 children，移交给其它组件去处理。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记19","slug":"vue日记19","date":"2019-07-05T15:33:29.000Z","updated":"2019-07-12T13:43:10.073Z","comments":true,"path":"2019/07/05/vue日记19/","link":"","permalink":"http://www.hefang.site/2019/07/05/vue日记19/","excerpt":"","text":"vue日记19自定义指令简介除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能： 12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 如果想注册局部指令，组件中也接受一个 directives 的选项：12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：1&lt;input v-focus&gt; 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用 钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性：name：指令名，不包括 v- 前缀。value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可 用。无论值是否改变都可用。expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用 ==注意==：除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行 这是一个使用了这些属性的自定义钩子样例：123456789101112131415161718192021&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = &apos;name: &apos; + s(binding.name) + &apos;&lt;br&gt;&apos; + &apos;value: &apos; + s(binding.value) + &apos;&lt;br&gt;&apos; + &apos;expression: &apos; + s(binding.expression) + &apos;&lt;br&gt;&apos; + &apos;argument: &apos; + s(binding.arg) + &apos;&lt;br&gt;&apos; + &apos;modifiers: &apos; + s(binding.modifiers) + &apos;&lt;br&gt;&apos; + &apos;vnode keys: &apos; + Object.keys(vnode).join(&apos;, &apos;) &#125;&#125;)new Vue(&#123; el: &apos;#hook-arguments-example&apos;, data: &#123; message: &apos;hello!&apos; &#125;&#125;) 动态指令参数指令的参数可以是动态的。例如，在 v-mydirective:[argument]=”value” 中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用 例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：1234567891011121314&lt;div id=&quot;baseexample&quot;&gt; &lt;p&gt;Scroll down the page&lt;/p&gt; &lt;p v-pin=&quot;200&quot;&gt;Stick me 200px from the top of the page&lt;/p&gt;&lt;/div&gt;Vue.directive(&apos;pin&apos;, &#123; bind: function (el, binding, vnode) &#123; el.style.position = &apos;fixed&apos; el.style.top = binding.value + &apos;px&apos; &#125;&#125;)new Vue(&#123; el: &apos;#baseexample&apos;&#125;) 这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新1234567891011121314151617181920&lt;div id=&quot;dynamicexample&quot;&gt; &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt; &lt;p v-pin:[direction]=&quot;200&quot;&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt;Vue.directive(&apos;pin&apos;, &#123; bind: function (el, binding, vnode) &#123; el.style.position = &apos;fixed&apos; var s = (binding.arg == &apos;left&apos; ? &apos;left&apos; : &apos;top&apos;) el.style[s] = binding.value + &apos;px&apos; &#125;&#125;)new Vue(&#123; el: &apos;#dynamicexample&apos;, data: function () &#123; return &#123; direction: &apos;left&apos; &#125; &#125;&#125;) 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:123Vue.directive(&apos;color-swatch&apos;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。12345&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, function (el, binding) &#123; console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记18","slug":"vue日记18","date":"2019-07-05T15:32:29.000Z","updated":"2019-07-12T13:43:00.697Z","comments":true,"path":"2019/07/05/vue日记18/","link":"","permalink":"http://www.hefang.site/2019/07/05/vue日记18/","excerpt":"","text":"vue日记18可复用性 &amp; 组合混入基础混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项例子：12345678910111213141516171819202122// 定义一个混入对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log(&apos;hello from mixin!&apos;) &#125; &#125;&#125;// 定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // =&gt; &quot;hello from mixin!&quot;``` #### 选项合并当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先 var mixin = { data: function () { return { message: ‘hello’, foo: ‘abc’ } }} new Vue({ mixins: [mixin], data: function () { return { message: ‘goodbye’, bar: ‘def’ } }, created: function () { console.log(this.$data) // =&gt; { message: “goodbye”, foo: “abc”, bar: “def” } }})1同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 var mixin = { created: function () { console.log(‘混入对象的钩子被调用’) }} new Vue({ mixins: [mixin], created: function () { console.log(‘组件钩子被调用’) }}) // =&gt; “混入对象的钩子被调用”// =&gt; “组件钩子被调用”1值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对 var mixin = { methods: { foo: function () { console.log(‘foo’) }, conflicting: function () { console.log(‘from mixin’) } }} var vm = new Vue({ mixins: [mixin], methods: { bar: function () { console.log(‘bar’) }, conflicting: function () { console.log(‘from self’) } }}) vm.foo() // =&gt; “foo”vm.bar() // =&gt; “bar”vm.conflicting() // =&gt; “from self”123==注意==：Vue.extend() 也使用同样的策略进行合并#### 全局混入混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑 // 为自定义的选项 ‘myOption’ 注入一个处理器。Vue.mixin({ created: function () { var myOption = this.$options.myOption if (myOption) { console.log(myOption) } }}) new Vue({ myOption: ‘hello!’})// =&gt; “hello!”12#### 自定义选项合并策略自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数： Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) { // 返回合并后的值}1对于多数值为对象的选项，可以使用与 methods 相同的合并策略： var strategies = Vue.config.optionMergeStrategiesstrategies.myOption = strategies.methods1可以在 Vuex 1.x 的混入策略里找到一个更高级的例子： const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) { if (!toVal) return fromVal if (!fromVal) return toVal return { getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) }}`","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记17","slug":"vue日记17","date":"2019-07-05T15:30:29.000Z","updated":"2019-07-12T13:42:07.769Z","comments":true,"path":"2019/07/05/vue日记17/","link":"","permalink":"http://www.hefang.site/2019/07/05/vue日记17/","excerpt":"","text":"vue日记17状态过渡 Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如： 数字和运算 颜色的显示 SVG 节点的位置 元素的大小和其他的属性 这些数据要么本身就以数值形式存储，要么可以转换为数值。有了这些数值后，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态 状态动画与侦听器通过侦听器我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用 GreenSock 一个例子：123456789101112131415161718192021222324&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#animated-number-demo&apos;, data: &#123; number: 0, tweenedNumber: 0 &#125;, computed: &#123; animatedNumber: function() &#123; return this.tweenedNumber.toFixed(0); &#125; &#125;, watch: &#123; number: function(newValue) &#123; TweenLite.to(this.$data, 0.5, &#123; tweenedNumber: newValue &#125;); &#125; &#125;&#125;) 但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Tween.js 和 Color.js 实现一个例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/color-js@1.0.3&quot;&gt;&lt;/script&gt;&lt;div id=&quot;example-7&quot;&gt; &lt;input v-model=&quot;colorQuery&quot; v-on:keyup.enter=&quot;updateColor&quot; placeholder=&quot;Enter a color&quot; &gt; &lt;button v-on:click=&quot;updateColor&quot;&gt;Update&lt;/button&gt; &lt;p&gt;Preview:&lt;/p&gt; &lt;span v-bind:style=&quot;&#123; backgroundColor: tweenedCSSColor &#125;&quot; class=&quot;example-7-color-preview&quot; &gt;&lt;/span&gt; &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;&lt;/div&gt;var Color = net.brehaut.Colornew Vue(&#123; el: &apos;#example-7&apos;, data: &#123; colorQuery: &apos;&apos;, color: &#123; red: 0, green: 0, blue: 0, alpha: 1 &#125;, tweenedColor: &#123;&#125; &#125;, created: function () &#123; this.tweenedColor = Object.assign(&#123;&#125;, this.color) &#125;, watch: &#123; color: function () &#123; function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() &#125; &#125;, computed: &#123; tweenedCSSColor: function () &#123; return new Color(&#123; red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha &#125;).toCSS() &#125; &#125;, methods: &#123; updateColor: function () &#123; this.color = new Color(this.colorQuery).toRGB() this.colorQuery = &apos;&apos; &#125; &#125;&#125;).example-7-color-preview &#123; display: inline-block; width: 50px; height: 50px;&#125; 动态状态过渡就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果 把过渡放到组件里管理太多的状态过渡会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;example-8&quot;&gt; &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; + &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; = &#123;&#123; result &#125;&#125; &lt;p&gt; &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; + &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; = &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt; &lt;/p&gt;&lt;/div&gt;// 这种复杂的补间动画逻辑可以被复用// 任何整数都可以执行动画// 组件化使我们的界面十分清晰// 可以支持更多更复杂的动态过渡// 策略。Vue.component(&apos;animated-integer&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&apos;, props: &#123; value: &#123; type: Number, required: true &#125; &#125;, data: function () &#123; return &#123; tweeningValue: 0 &#125; &#125;, watch: &#123; value: function (newValue, oldValue) &#123; this.tween(oldValue, newValue) &#125; &#125;, mounted: function () &#123; this.tween(0, this.value) &#125;, methods: &#123; tween: function (startValue, endValue) &#123; var vm = this function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(&#123; tweeningValue: startValue &#125;) .to(&#123; tweeningValue: endValue &#125;, 500) .onUpdate(function () &#123; vm.tweeningValue = this.tweeningValue.toFixed(0) &#125;) .start() animate() &#125; &#125;&#125;)// 所有的复杂度都已经从 Vue 的主实例中移除！new Vue(&#123; el: &apos;#example-8&apos;, data: &#123; firstNumber: 20, secondNumber: 40 &#125;, computed: &#123; result: function () &#123; return this.firstNumber + this.secondNumber &#125; &#125;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记16","slug":"vue日记16","date":"2019-07-05T14:29:29.000Z","updated":"2019-07-12T13:40:13.259Z","comments":true,"path":"2019/07/05/vue日记16/","link":"","permalink":"http://www.hefang.site/2019/07/05/vue日记16/","excerpt":"","text":"vue日记16进入/离开 &amp; 列表过渡概述 Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加==进入==/==离开==过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 12345678910111213141516171819202122&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125;&#125;).fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同) 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换 ==v-enter==：==定义进入过渡的开始状态==。在元素被插入之前生效，在元素被插入之后的下一帧移除。 ==v-enter-active==：==定义进入过渡生效时的状态==。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 ==v-enter-to==: 2.1.8版及以上 ==定义进入过渡的结束状态==。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 ==v-leave==: ==定义离开过渡的开始状态==。在离开过渡被触发时立刻生效，下一帧被移除。 ==v-leave-active==：==定义离开过渡生效时的状态==。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 ==v-leave-to==: 2.1.8版及以上 ==定义离开过渡的结束状态==。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的&lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enterv-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线 CSS 过渡常用的过渡都是使用 CSS 过渡例子:1234567891011121314151617181920212223242526272829&lt;div id=&quot;example-1&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125;&#125;)/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; CSS 动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除例子:12345678910111213141516171819202122232425262728293031&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;).bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡的类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用例子:123456789101112131415161718192021&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; show: true &#125;&#125;) 同时使用过渡和动画Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型 显性的过渡持续时间在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果在这种情况下你可以用 组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计)：1&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt; 你也可以定制进入和移出的持续时间：1&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt; JavaScript 钩子可以在属性中声明 JavaScript 钩子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用==注意：== 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响 一个使用 Velocity.js 的简单例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择--&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;example-4&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; v-bind:css=&quot;false&quot; &gt; &lt;p v-if=&quot;show&quot;&gt; Demo &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; show: false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.transformOrigin = &apos;left&apos; &#125;, enter: function (el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: &apos;1.4em&apos; &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: &apos;1em&apos; &#125;, &#123; complete: done &#125;) &#125;, leave: function (el, done) &#123; Velocity(el, &#123; translateX: &apos;15px&apos;, rotateZ: &apos;50deg&apos; &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: &apos;100deg&apos; &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: &apos;45deg&apos;, translateY: &apos;30px&apos;, translateX: &apos;30px&apos;, opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;&#125;) 初始渲染的过渡可以通过 appear 特性设置节点在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名12345678&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+) appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：123456789&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot; v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 在上面的例子中，无论是 appear 特性还是 v-on:appear 钩子都会生成初始渲染过渡。 多个元素的过渡我们之后讨论多个组件的过渡，对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; ==注意：==当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 组件中的多个元素设置 key 是一个更好的实践 例子：12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 在一些场景中，也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为： 12345&lt;transition&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。例如：1234567891011&lt;transition&gt; &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt; 可以重写为： 12345678910111213141516&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case &apos;saved&apos;: return &apos;Edit&apos; case &apos;edited&apos;: return &apos;Save&apos; case &apos;editing&apos;: return &apos;Cancel&apos; &#125; &#125;&#125; 过渡模式在 “on” 按钮和 “off” 按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 的默认行为 - 进入和离开同时发生 同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 ==过渡模式== in-out：新元素先进行过渡，完成之后当前元素过渡离开 out-in：当前元素先进行过渡，完成之后新元素过渡进入 用 out-in 重写之前的开关按钮过渡： 123&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;!-- ... the buttons ... --&gt;&lt;/transition&gt; in-out 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件：1234567891011121314151617181920212223242526&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;new Vue(&#123; el: &apos;#transition-components-demo&apos;, data: &#123; view: &apos;v-a&apos; &#125;, components: &#123; &apos;v-a&apos;: &#123; template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos; &#125;, &apos;v-b&apos;: &#123; template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos; &#125; &#125;&#125;).component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to/* .component-fade-leave-active for below version 2.1.8 */ &#123; opacity: 0;&#125; 列表过渡 单个节点 同一时间渲染多个节点中的一个 那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用 &lt;transition-group&gt; 组件。在我们深入例子之前，先了解关于这个组件的几个特点: 不同于 &lt;transition&gt;，它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag 特性更换为其他元素 过渡模式不可用，因为我们不再相互切换特有的元素 内部元素 总是需要 提供唯一的 key 属性值 列表的进入/离开过渡进入和离开的过渡使用之前一样的 CSS 类名1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#list-demo&apos;, data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;).list-item &#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-to/* .list-leave-active for below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125; 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： 123456789101112131415161718192021222324&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#flip-list-demo&apos;, data: &#123; items: [1,2,3,4,5,6,7,8,9] &#125;, methods: &#123; shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;).flip-list-move &#123; transition: transform 1s;&#125; 这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置 我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;list-complete-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;transition-group name=&quot;list-complete&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-complete-item&quot; &gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#list-complete-demo&apos;, data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;).list-complete-item &#123; transition: all 1s; display: inline-block; margin-right: 10px;&#125;.list-complete-enter, .list-complete-leave-to/* .list-complete-leave-active for below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125;.list-complete-leave-active &#123; position: absolute;&#125; 列表的交错过渡通过 data 属性与 JavaScript 通信 ，就可以实现列表的交错过渡：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;staggered-list-demo&quot;&gt; &lt;input v-model=&quot;query&quot;&gt; &lt;transition-group name=&quot;staggered-fade&quot; tag=&quot;ul&quot; v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; &gt; &lt;li v-for=&quot;(item, index) in computedList&quot; v-bind:key=&quot;item.msg&quot; v-bind:data-index=&quot;index&quot; &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#staggered-list-demo&apos;, data: &#123; query: &apos;&apos;, list: [ &#123; msg: &apos;Bruce Lee&apos; &#125;, &#123; msg: &apos;Jackie Chan&apos; &#125;, &#123; msg: &apos;Chuck Norris&apos; &#125;, &#123; msg: &apos;Jet Li&apos; &#125;, &#123; msg: &apos;Kung Fury&apos; &#125; ] &#125;, computed: &#123; computedList: function () &#123; var vm = this return this.list.filter(function (item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 1, height: &apos;1.6em&apos; &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125;&#125;) 可复用的过渡过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 &lt;transition&gt; 或者 &lt;transition-group&gt; 作为根组件，然后将任何子组件放置在其中就可以了例子:1234567891011121314151617181920Vue.component(&apos;my-special-transition&apos;, &#123; template: &apos;\\ &lt;transition\\ name=&quot;very-special-transition&quot;\\ mode=&quot;out-in&quot;\\ v-on:before-enter=&quot;beforeEnter&quot;\\ v-on:after-enter=&quot;afterEnter&quot;\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ &apos;, methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;) 函数式组件更适合完成这个任务：1234567891011121314151617181920Vue.component(&apos;my-special-transition&apos;, &#123; functional: true, render: function (createElement, context) &#123; var data = &#123; props: &#123; name: &apos;very-special-transition&apos;, mode: &apos;out-in&apos; &#125;, on: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125; &#125; return createElement(&apos;transition&apos;, data, context.children) &#125;&#125;) 动态过渡在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 name 特性来绑定动态值123&lt;transition v-bind:name=&quot;transitionName&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 所有过渡特性都可以动态绑定，但我们不仅仅只有特性可以利用，还可以通过事件钩子获取上下文中的所有数据，因为事件钩子都是方法。这意味着，根据组件的状态不同，你的 JavaScript 过渡会有不同的表现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;dynamic-fade-demo&quot; class=&quot;demo&quot;&gt; Fade In: &lt;input type=&quot;range&quot; v-model=&quot;fadeInDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; Fade Out: &lt;input type=&quot;range&quot; v-model=&quot;fadeOutDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; &lt;transition v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=&quot;stop&quot; v-on:click=&quot;stop = false; show = false&quot; &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=&quot;stop = true&quot; &gt;Stop it!&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#dynamic-fade-demo&apos;, data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration, complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration, complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记15","slug":"vue日记15","date":"2019-07-05T12:30:29.000Z","updated":"2019-07-12T13:38:52.801Z","comments":true,"path":"2019/07/05/vue日记15/","link":"","permalink":"http://www.hefang.site/2019/07/05/vue日记15/","excerpt":"","text":"vue日记15处理边界情况访问元素 &amp; 组件在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的 访问根实例在每个 new Vue 实例的子组件中，其根实例可以通过 $root 属性进行访问。例如，在这个根实例中：123456789101112// Vue 根实例new Vue(&#123; data: &#123; foo: 1 &#125;, computed: &#123; bar: function () &#123; /* ... */ &#125; &#125;, methods: &#123; baz: function () &#123; /* ... */ &#125; &#125;&#125;) 所有的子组件都可以将这个实例作为一个全局 store 来访问或使用1234567891011// 获取根组件的数据this.$root.foo// 写入根组件的数据this.$root.foo = 2// 访问根组件的计算属性this.$root.bar// 调用根组件的方法this.$root.baz() ==注意:==对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 Vuex 来管理应用的状态 访问父级组件实例和 $root类似，$parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。 访问子组件实例或子元素尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 特性为这个子组件赋予一个 ID 引用。例如：1&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt; 现在在你已经定义了这个 ref 的组件里，你可以使用：1this.$refs.usernameInput 来访问这个 &lt;base-input&gt; 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该&lt;base-input&gt; 组件也可以使用一个类似的 ref 提供对内部这个指定元素的访问，例如：1&lt;input ref=&quot;input&quot;&gt; 甚至可以通过其父级组件定义方法：123456methods: &#123; // 用来从父级组件聚焦输入框 focus: function () &#123; this.$refs.input.focus() &#125;&#125; 这样就允许父级组件通过下面的代码聚焦 里的输入框：1this.$refs.usernameInput.focus() 当 ref 和 v-for 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。 依赖注入它用到了两个新的实例选项：provide 和 injectprovide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 &lt;google-map&gt; 内部的 getMap 方法：12345provide: function () &#123; return &#123; getMap: this.getMap &#125;&#125; 然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性：1inject: [&apos;getMap&apos;] 相比 $parent 来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样 实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了： 祖先组件不需要知道哪些后代组件使用它提供的属性 后代组件不需要知道被注入的属性来自哪里 程序化的事件侦听器现在，你已经知道了 $emit 的用法，它可以被 v-on 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以： 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 1234567891011121314// 一次性将这个日期选择器附加到一个输入框上// 它会被挂载到 DOM 上。mounted: function () &#123; // Pikaday 是一个第三方日期选择器的库 this.picker = new Pikaday(&#123; field: this.$refs.input, format: &apos;YYYY-MM-DD&apos; &#125;)&#125;,// 在组件被销毁之前，// 也销毁这个日期选择器。beforeDestroy: function () &#123; this.picker.destroy()&#125; 这里有两个潜在的问题： 它需要在这个组件实例中保存这个 picker，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西 你应该通过一个程序化的侦听器解决这两个问题：12345678910mounted: function () &#123; var picker = new Pikaday(&#123; field: this.$refs.input, format: &apos;YYYY-MM-DD&apos; &#125;) this.$once(&apos;hook:beforeDestroy&apos;, function () &#123; picker.destroy() &#125;)&#125; 使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：12345678910111213141516mounted: function () &#123; this.attachDatepicker(&apos;startDateInput&apos;) this.attachDatepicker(&apos;endDateInput&apos;)&#125;,methods: &#123; attachDatepicker: function (refName) &#123; var picker = new Pikaday(&#123; field: this.$refs[refName], format: &apos;YYYY-MM-DD&apos; &#125;) this.$once(&apos;hook:beforeDestroy&apos;, function () &#123; picker.destroy() &#125;) &#125;&#125; 循环引用递归组件组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事：1name: &apos;unique-name-of-my-component&apos; 当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。123Vue.component(&apos;unique-name-of-my-component&apos;, &#123; // ...&#125;) 稍有不慎，递归组件就可能导致无限循环：12name: &apos;stack-overflow&apos;,template: &apos;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&apos; 组件之间的循环引用假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 &lt;tree-folder&gt; 组件，模板是这样的： 1234&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;&lt;/p&gt; 还有一个&lt;tree-folder-contents&gt;组件，模板是这样的： 123456&lt;ul&gt; &lt;li v-for=&quot;child in children&quot;&gt; &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A 反正是需要 B 的，但是我们不需要先解析 B。” 在我们的例子中，把&lt;tree-folder&gt; 组件设为了那个点。我们知道那个产生悖论的子组件是 &lt;tree-folder-contents&gt; 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它：123beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require(&apos;./tree-folder-contents.vue&apos;).default&#125; 或者，在本地注册组件的时候，你可以使用 webpack 的异步 import：123components: &#123; TreeFolderContents: () =&gt; import(&apos;./tree-folder-contents.vue&apos;)&#125; 模板定义的替代品内联模板当 inline-template 这个特殊的特性出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt; &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 内联模板需要定义在 Vue 所属的 DOM 元素内==注意：==不过，inline-template 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 &lt;template&gt; 元素来定义模板 X-Template另一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。例如： 1234567&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&apos;hello-world&apos;, &#123; template: &apos;#hello-world-template&apos;&#125;) x-template 需要定义在 Vue 所属的 DOM 元素外 强制更新过 v-once 创建低开销的静态组件:渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来，就像这样：12345678Vue.component(&apos;terms-of-service&apos;, &#123; template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记14","slug":"vue日记14","date":"2019-07-04T13:29:29.000Z","updated":"2019-07-12T13:36:55.964Z","comments":true,"path":"2019/07/04/vue日记14/","link":"","permalink":"http://www.hefang.site/2019/07/04/vue日记14/","excerpt":"","text":"vue日记14动态组件 &amp; 异步组件在动态组件上使用 keep-alive我们之前曾经在一个多标签的界面中使用 is 特性来切换不同的组件：1&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; 重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 &lt;keep-alive&gt; 元素将其动态组件包裹起来1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 如你所见，这个工厂函数会收到一个 resolve 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 reject(reason) 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：123456Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require([&apos;./my-async-component&apos;], resolve)&#125;) 你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样：12345Vue.component( &apos;async-webpack-example&apos;, // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;) 处理加载状态这里的异步组件工厂函数也可以返回一个如下格式的对象：12345678910111213const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import(&apos;./MyComponent.vue&apos;), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记13","slug":"vue日记13","date":"2019-07-04T12:30:29.000Z","updated":"2019-07-12T13:35:50.800Z","comments":true,"path":"2019/07/04/vue日记13/","link":"","permalink":"http://www.hefang.site/2019/07/04/vue日记13/","excerpt":"","text":"vue日记13插槽插槽内容Vue 实现了一套内容分发的 API，将 元素作为承载分发内容的出口 它允许你像这样合成组件：123&lt;navigation-link url=&quot;/profile&quot;&gt; Your Profile&lt;/navigation-link&gt; 然后你在 的模板中可能会写为：12345&lt;a v-bind:href=&quot;url&quot; class=&quot;nav-link&quot; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 当组件渲染的时候， 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：12345&lt;navigation-link url=&quot;/profile&quot;&gt; &lt;!-- 添加一个 Font Awesome 图标 --&gt; &lt;span class=&quot;fa fa-user&quot;&gt;&lt;/span&gt; Your Profile&lt;/navigation-link&gt; 甚至其它的组件：12345&lt;navigation-link url=&quot;/profile&quot;&gt; &lt;!-- 添加一个图标的组件 --&gt; &lt;font-awesome-icon name=&quot;user&quot;&gt;&lt;/font-awesome-icon&gt; Your Profile&lt;/navigation-link&gt; 如果 &lt;navigation-link&gt; 没有包含一个 &lt;slot&gt; 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃 编译作用域该插槽跟模板的其它地方一样可以访问相同的实例属性 (也就是相同的“作用域”)，而不能访问 的作用域。例如 url 是访问不到的：url1234567 Clicking here will send you to: &#123;&#123; url &#125;&#125; &lt;!-- 这里的 `url` 会是 undefined，因为 &quot;/profile&quot; 是 _传递给_ &lt;navigation-link&gt; 的而不是 在 &lt;navigation-link&gt; 组件*内部*定义的。 --&gt;&lt;/navigation-link&gt; 注意：==父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的== 后备内容有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 &lt;submit-button&gt;组件中：123&lt;button type=&quot;submit&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/button&gt; 我们可能希望这个 &lt;button&gt; 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在&lt;slot&gt; 标签内：123&lt;button type=&quot;submit&quot;&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 现在当我在一个父级组件中使用 &lt;submit-button&gt; 并且不提供任何插槽内容时： 1&lt;submit-button&gt;&lt;/submit-button&gt; 后备内容“Submit”将会被渲染：123&lt;button type=&quot;submit&quot;&gt; Submit&lt;/button&gt; 但是如果我们提供内容：123&lt;submit-button&gt; Save&lt;/submit-button&gt; 则这个提供的内容将会被渲染从而取代后备内容：123&lt;button type=&quot;submit&quot;&gt; Save&lt;/button&gt; 具名插槽有时我们需要多个插槽。例如对于一个带有如下模板的 组件：1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;/footer&gt;&lt;/div&gt; 有时我们需要多个插槽。例如对于一个带有如下模板的 组件：1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;/footer&gt;&lt;/div&gt; &lt;template&gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的&lt;template&gt; 中的内容都会被视为默认插槽的内容。1234567891011121314&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 作用域插槽==作用域插槽的关键之处就在于，父组件能接收来自子组件的slot传递过来的参数==有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 &lt;current-user&gt; 组件：123&lt;span&gt; &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt;&lt;/span&gt; 为了让 user 在父级的插槽内容可用，我们可以将 user 作为 &lt;slot&gt; 元素的一个特性绑定上去：12345&lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &#123;&#123; user.lastName &#125;&#125; &lt;/slot&gt;&lt;/span&gt; 绑定在 &lt;slot&gt; 元素上的特性被称为插槽 prop。现在在父级作用域中，我们可以给 v-slot 带一个值来定义我们提供的插槽 prop 的名字：12345&lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 独占默认插槽的缩写语法在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot 直接用在组件上：123&lt;current-user v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125;&lt;/current-user&gt; 或者：123&lt;current-user v-slot=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125;&lt;/current-user&gt; 只要出现多个插槽，请始终为所有的插槽使用完整的基于 &lt;template&gt; 的语法：123456789&lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt; ... &lt;/template&gt;&lt;/current-user&gt; 解构插槽 Prop作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里123function (slotProps) &#123; // 插槽内容&#125; 这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 (单文件组件或现代浏览器)，你也可以使用 ES2015 解构来传入具体的插槽 prop，如下:123&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 user 重命名为 person：123&lt;current-user v-slot=&quot;&#123; user: person &#125;&quot;&gt; &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt; 你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：123&lt;current-user v-slot=&quot;&#123; user = &#123; firstName: &apos;Guest&apos; &#125; &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 动态插槽名动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt; 具名插槽的缩写跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header123456789101112&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template #footer&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 其它示例插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记12","slug":"vue日记12","date":"2019-07-04T12:29:29.000Z","updated":"2019-07-12T13:34:23.748Z","comments":true,"path":"2019/07/04/vue日记12/","link":"","permalink":"http://www.hefang.site/2019/07/04/vue日记12/","excerpt":"","text":"vue日记12自定义事件自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突：12345678910111213141516Vue.component(&apos;base-checkbox&apos;, &#123; model: &#123; prop: &apos;checked&apos;, event: &apos;change&apos; &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot; &gt; `&#125;) 现在在这个组件上使用 v-model 的时候：1&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop 将原生事件绑定到组件在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符：1&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt; 在有的时候这是很有用的，不过在你尝试监听一个类似 &lt;input&gt; 的非常特定的元素时，这并不是个好主意。比如上述 组件可能做了如下重构，所以根元素实际上是一个 元素：1234567&lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;&gt;&lt;/label&gt; 这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用 $listenersVue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：1234&#123; focus: function (event) &#123; /* ... */ &#125; input: function (value) &#123; /* ... */ &#125;,&#125; 1234567891011121314151617181920212223242526272829303132Vue.component(&apos;base-input&apos;, &#123; inheritAttrs: false, props: [&apos;label&apos;, &apos;value&apos;], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign(&#123;&#125;, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 &#123; // 这里确保组件配合 `v-model` 的工作 input: function (event) &#123; vm.$emit(&apos;input&apos;, event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on=&quot;inputListeners&quot; &gt; &lt;/label&gt; `&#125;) 现在 组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 &lt;input&gt; 元素一样使用了：所有跟它相同的特性和监听器的都可以工作 .sync 修饰符在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。 这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：1this.$emit(&apos;update:title&apos;, newTitle) 然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：1234&lt;text-document v-bind:title=&quot;doc.title&quot; v-on:update:title=&quot;doc.title = $event&quot;&lt;/text-document&gt; 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符：1&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt; 注意:带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model 当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：1&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt; 这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记11","slug":"vue日记11","date":"2019-07-03T14:29:29.000Z","updated":"2019-07-11T15:33:07.689Z","comments":true,"path":"2019/07/03/vue日记11/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记11/","excerpt":"","text":"vue日记11PropProp 的大小写 (camelCase vs kebab-case)HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名1234567Vue.component(&apos;blog-post&apos;, &#123; // 在 JavaScript 中是 camelCase 的 props: [&apos;postTitle&apos;], template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;)&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt; 注意：如果你使用字符串模板，那么这个限制就不存在了 Prop 类型123456789props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; 传递静态或动态 Prop1&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt; 你也知道 prop 可以通过 v-bind 动态赋值，例如：1234567&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title + &apos; by &apos; + post.author.name&quot;&lt;/blog-post&gt; 在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop 传入一个数字123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt; 传入一个布尔值123456789&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt; 传入一个数组123456&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:comment-ids=&quot;post.commentIds&quot;&gt;&lt;/blog-post&gt; 传入一个对象1234567891011&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:author=&quot;&#123; name: &apos;Veronica&apos;, company: &apos;Veridian Dynamics&apos; &#125;&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt; 传入一个对象的所有属性将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：123456post: &#123; id: 1, title: &apos;My Journey with Vue&apos;&#125;&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt; 等价于：1234&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单向数据流两种常见的试图改变一个 prop 的情形1.这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：123456props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 2.这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; Prop 验证为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：123456789101112131415161718192021222324252627282930313233Vue.component(&apos;my-component&apos;, &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 类型检查type 可以是下列原生构造函数中的一个： StringNumberBooleanArrayObjectDateFunctionSymbol 非 Prop 的特性一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记10","slug":"vue日记10","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T15:31:38.407Z","comments":true,"path":"2019/07/03/vue日记10/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记10/","excerpt":"","text":"vue日记10组件注册组件名大小写使用 kebab-case1Vue.component(&apos;my-component-name&apos;, &#123; /* ... */ &#125;) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如&lt;my-component-name&gt; 使用 PascalCase1Vue.component(&apos;MyComponentName&apos;, &#123; /* ... */ &#125;) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说&lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 全局注册12345678910Vue.component(&apos;component-a&apos;, &#123; /* ... */ &#125;)Vue.component(&apos;component-b&apos;, &#123; /* ... */ &#125;)Vue.component(&apos;component-c&apos;, &#123; /* ... */ &#125;)new Vue(&#123; el: &apos;#app&apos; &#125;)&lt;div id=&quot;app&quot;&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt; 局部注册1234567new Vue(&#123; el: &apos;#app&apos;, components: &#123; &apos;component-a&apos;: ComponentA, &apos;component-b&apos;: ComponentB &#125;&#125;) 在模块系统中局部注册1234567891011import ComponentA from &apos;./ComponentA&apos;import ComponentC from &apos;./ComponentC&apos;export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记09","slug":"vue日记09","date":"2019-07-03T13:27:29.000Z","updated":"2019-07-11T15:33:00.672Z","comments":true,"path":"2019/07/03/vue日记09/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记09/","excerpt":"","text":"vue日记09组件基础基本示例123456789// 定义一个名为 button-counter 的新组件Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;&#125;) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：1234&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#components-demo&apos; &#125;) 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项 组件的复用你可以将组件进行任意次数的复用：12345&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建 data 必须是一个函数当我们定义这个 &lt;button-counter&gt; 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：12345data: function () &#123; return &#123; count: 0 &#125;&#125; 组件的注册全局注册:123Vue.component(&apos;my-component-name&apos;, &#123; // ... options ...&#125;) 局部注册:123456789var app = new vue(&#123; el:&quot;#app&quot;, data:&#123; ... &#125;, components:&#123; &apos;component-a&apos;: ComponentA, &#125;&#125;) 通过 Prop 向子组件传递数据Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性1234Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;title&apos;], template: &apos;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&apos;&#125;) 然而在一个典型的应用中，你可能在 data 里有一个博文的数组：12345678910new Vue(&#123; el: &apos;#blog-post-demo&apos;, data: &#123; posts: [ &#123; id: 1, title: &apos;My journey with Vue&apos; &#125;, &#123; id: 2, title: &apos;Blogging with Vue&apos; &#125;, &#123; id: 3, title: &apos;Why Vue is so fun&apos; &#125; ] &#125;&#125;) 并想要为每篇博文渲染一个组件：12345&lt;blog-post v-for=&quot;post in posts&quot; v-bind:key=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单个根元素将模板的内容包裹在一个父元素内1234567891011121314&lt;blog-post v-for=&quot;post in posts&quot; v-bind:key=&quot;post.id&quot; v-bind:post=&quot;post&quot;&gt;&lt;/blog-post&gt;Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;post&apos;], template: ` &lt;div class=&quot;blog-post&quot;&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt; &lt;/div&gt; `&#125;) 监听子组件事件父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件123456789&lt;blog-post ... v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt; methods:&#123; onEnlargeText(value)&#123; this.value = value &#125; &#125; 子组件可以通过调用内建的 $emit 方法 并传入事件名称来触发一个事件123&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;,value)&quot;&gt; Enlarge text&lt;/button&gt; 在组件上使用 v-model自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：1&lt;input v-model=&quot;searchText&quot;&gt; 等价于：123&lt;inputv-bind:value=&quot;searchText&quot;v-on:input=&quot;searchText = $event.target.value&quot;&gt; 当用在组件上时，v-model 则会这样：1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value 特性绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 写成代码之后是这样的：12345678Vue.components(&apos;custom-input&apos;,&#123; props：[&apos;value&apos;], template:` &lt;input :value=&quot;value&quot; @input=&quot;$emit(&apos;input&apos;,$event.target.value)&quot; &gt; `&#125;)渲染之后：&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 通过插槽分发内容123456789101112&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt;Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 动态组件通过 Vue 的 元素加一个特殊的 is 特性来实现12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记08","slug":"vue日记08","date":"2019-07-03T12:27:29.000Z","updated":"2019-07-11T15:35:31.571Z","comments":true,"path":"2019/07/03/vue日记08/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记08/","excerpt":"","text":"vue日记08表单输入绑定基础用法用 v-model 指令在表单input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理 v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件: text 和 textarea 元素使用 value 属性和input 事件 checkbox 和 radio 使用 checked 属性和change 事件 select 字段将 value 作为 prop 并将change 作为事件 文本 text12&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本 textarea1234&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt; 复选框单个复选框，绑定到布尔值：12&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，绑定到同一个数组：1234567891011121314151617&lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; checkedNames: [] &#125;&#125;) 单选按钮12345678910111213141516&lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; picked: &apos;&apos; &#125;&#125;) 选择框单选时:12345678910111213141516&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;&apos; &#125;&#125;) 多选时 (绑定到一个数组)：12345678910111213141516&lt;div id=&quot;example-6&quot;&gt; &lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-6&apos;, data: &#123; selected: [] &#125;&#125; 用 v-for 渲染的动态选项：1234567891011121314151617&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;A&apos;, options: [ &#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125; ] &#125;&#125;) 值绑定对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：12345678910&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;&lt;/select&gt; 但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串 修饰符.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记07","slug":"vue日记07","date":"2019-07-02T15:27:29.000Z","updated":"2019-07-11T15:34:17.964Z","comments":true,"path":"2019/07/02/vue日记07/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记07/","excerpt":"","text":"vue日记07事件处理事件监听v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码1234567891011&lt;div id=&quot;example-1&quot;&gt; &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; counter: 0 &#125;&#125;) 事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。例子：123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;onClick&quot;&gt;Greet&lt;/button&gt;&lt;/div&gt;var app = new Vue(&#123; el：&quot;#app&quot;, data:&#123; age:25 &#125;, methods:&#123; onClick(even)&#123; alert(this.age) &#125; if(even) &#123; alert(even.target.tagName) &#125; &#125; &#125;) 内联处理器中的防范除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：12345678910111213&lt;div id=&quot;example-3&quot;&gt; &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt; &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) 事件修饰符Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的 .stop .prevent .capture .self .once .passive 按键码使用 keyCode 特性也是允许的： 1&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器 .ctrl .alt .shift .meta exact 修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 鼠标按钮修饰符修饰符会限制处理函数仅响应特定的鼠标按钮 .left .right .middle","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记05","slug":"vue日记05","date":"2019-07-02T14:27:29.000Z","updated":"2019-07-11T15:31:50.080Z","comments":true,"path":"2019/07/02/vue日记05/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记05/","excerpt":"","text":"vue日记05条件渲染v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。v-else你可以使用 v-else 指令来表示 v-if 的“else 块”：例子：1234567&lt;div&gt; &lt;div v-if=&quot;loading&quot;&gt;loading icon&lt;/div&gt; &lt;div v-else&gt;content&lt;/div&gt;&lt;/div&gt;data:&#123; loading:true&#125; v-else-if顾名思义，充当 v-if 的“else-if 块”，可以连续使用：1234&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;C&lt;/div&gt;&lt;div v-else&gt;Not A/B/C&lt;/div&gt; 用 key 管理可复用的元素官网例子：12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; 如果不增加key的话在loginType中输入的在值，不会被清除现在每次切换的时候，输入框都会被重新渲染 v-showv-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 注意：v-show 不支持 &lt;template&gt; 元素，也不支持 v-else v-show 与 v-ifv-if是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当被销毁和重建v-if也是有惰性的，如果在初始渲染时候条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记06","slug":"vue日记06","date":"2019-07-02T14:27:29.000Z","updated":"2019-07-11T15:34:12.341Z","comments":true,"path":"2019/07/02/vue日记06/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记06/","excerpt":"","text":"vue日记06列表渲染用 v-for 把一个数组对应为一组元素我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名v-for 还支持一个可选的第二个参数，即当前项的索引例子：1234567891011&lt;ul&gt; &lt;li v-for=&quot;(list,index)in lists&quot;&gt;&#123;&#123;list.value&#125;&#125;&lt;/li&gt;&lt;/ul&gt;data:&#123; lists:[ &#123;value:0&#125;, &#123;value:1&#125;, &#123;value:2&#125; ]&#125; 用 v-for 来遍历一个对象的属性例子：1234567891011121314151617181920&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;)渲染结果： How to do lists in Vue Jane Doe 2016-04-10 提供第二个的参数为 property 名称 (也就是键名)：例子：123456789101112131415161718&lt;div v-for=&quot;(value, name) in object&quot;&gt; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;)渲染结果： title: How to do lists in Vue author: Jane Doe publishedAt: 2016-04-10 提供第三个的参数作为索引:123456789101112131415161718&lt;div v-for=&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;)渲染结果： 0.title: How to do lists in Vue 1.author: Jane Doe 2.publishedAt: 2016-04-10 维护状态当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：1&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 变异方法 (mutation method)Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：push() 方法可以向数组的末尾添加一个或者多个元素，并返回新的长度pop() 删除并返回数组的最后一个元素shift() 删除shift并返回数组的第一个元素unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。sort() 对数组的元素进行排序reverse() 方法用于颠倒数组中元素的顺序。 替换数组变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 filter()、concat() 和 slice() 。它们不会改变原始数组，而总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。slice()方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 对象变更检测注意事项对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性例如，对于：1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &apos;Anika&apos; &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, &apos;age&apos;, 27) 或者：使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：1vm.$set(vm.userProfile, &apos;age&apos;, 27) 显示过滤/排序后的结果用计算属性来返回过滤或排序后的数组。123456789101112&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 用methods方法来返回过滤或排序后的数组。123456789101112&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 在 v-for 里使用值范围v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。 123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 在 上使用 v-for可以利用带有 v-for 的 来循环渲染一段包含多个元素的内容123456&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for 与 v-if 一同使用v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下:1234&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt;上面的代码将只渲染未完成的 todo 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 )上。如：123456&lt;ul v-if=&quot;todos.length&quot;&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 在组件上使用 v-for在自定义组件上，你可以像在任何普通元素上一样使用 v-for 。1&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt; 2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记04","slug":"vue日记04","date":"2019-07-02T12:27:29.000Z","updated":"2019-07-11T15:31:52.168Z","comments":true,"path":"2019/07/02/vue日记04/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记04/","excerpt":"","text":"vue日记04Class 与 Styleclass 对象语法给 v-bind:class 一个对象，以动态地切换 class：1234567891011121314&lt;style&gt; .active &#123; background:red; &#125; .text &#123; color:green; &#125;&lt;/style&gt;&lt;div :class=&quot;&#123;active:isActive,text: hasError&#125;&quot;&gt;&lt;/div&gt;data:&#123; isActive:true , hasError:true &#125;渲染结果：&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; class 数组语法把一个数组传给 v-bind:class，以应用一个 class 列表1234567891011121314&lt;style&gt; .active&#123; background:yellow; &#125; .error&#123; color:red; &#125;&lt;/style&gt;&lt;div :class=&quot;[activeCalss,errorClass]&quot;&gt;&lt;/div&gt;data:&#123; activeCalss:&apos;active&apos;, errorClass:&apos;error&apos;&#125;渲染结果：&lt;div class=&quot;active error&quot;&gt;&lt;/div&gt; 当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：1&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt; style 对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：123456&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize&#125;&quot;&gt;&lt;/div&gt;data:&#123; activeColor:&apos;red&apos;, fontSize:&apos;30px&apos;&#125;渲染结果：&lt;div style=&quot;color:red font-size= 30xp&quot;&gt;&lt;/div&gt; 或者直接绑定到一个样式对象通常更好，这样是的模板更清晰：1234567&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;data:&#123; styleObject:&#123; activeColor:&apos;red&apos;, fontSize:&apos;30px&apos; &#125;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。 style 数组语法v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记03","slug":"vue日记03","date":"2019-07-02T10:27:29.000Z","updated":"2019-07-11T15:31:54.825Z","comments":true,"path":"2019/07/02/vue日记03/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记03/","excerpt":"","text":"vue日记03计算属性 - methods - watchexample：123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125;&lt;div&gt; 对于任何复杂的逻辑，应使用计算属性12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reversedMessage1()&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reversedMessage2&#125;&#125;&lt;/p&gt;&lt;div&gt;var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&apos;hello&apos; &#125;, methods:&#123; reversedMessage1 ()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; computed:&#123; reversedMessage2()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 以上计算属性和methods中定义的方法都可以得到结果，区别是：计算属性是基于它们的响应式的依赖进行缓存的，只有在它们的响应式的依赖发生改变的时候它们才会去重新求值，也就是说data中message的值不发生改变，多次reversedMessage会立即返回之前的计算结果，而不会再次执行函数对于methods，只要发生重新渲染，那么methods中的函数就会被调用 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。以官网例子： 使用watch：123456789101112131415161718&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 使用computed：1234567891011121314&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; firstName:&apos;Foo&apos;, lastName:&apos;Bar&apos;, &#125; watch:&#123; fullName()&#123; return this.firstName + &apos;&apos; + this.lastName &#125; &#125;&#125;) 相比较还是computed更合适 计算属性默认只有getter,不过在需要时你也可以提供一个setter官网例子:123456789101112computed:&#123; fullName:&#123; get()&#123; //getter return this.firstName + &apos;&apos; + this.lastName &#125;, set(newValue)&#123; //setter let names = newValue.split(&apos;&apos;) this.firstName = names[0] this.lastName = names[names.length -1] &#125; &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记02","slug":"vue日记02","date":"2019-07-02T04:27:29.000Z","updated":"2019-07-11T15:31:58.535Z","comments":true,"path":"2019/07/02/vue日记02/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记02/","excerpt":"","text":"vue日记02模板语法数据绑定最常见的形式就是使用mustache语法的文本差值:1&lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; JavaScript 表达式可以使用表达式进行简单的运算和三目运算等，Vue.js只支持单个表达式，不支持语句和流控制12&#123;&#123;1 + 1 * 1&#125;&#125;可以进行简单的运算 12&#123;&#123;1 &lt; 2 ? value :a&#125;&#125;可以使用三目运算符 12&#123;&#123;if( a &gt; 3)&#123;&#125;&#125;&#125;文本插值的形式，其中不能书写表达式,支持单个表达式 指令和事件指令是Vue模板中最常见的一项功能，它带有前缀v-,能快速帮助我们完成DOM操作循环渲染，显示和隐藏v-text 解析文本和作用一样‘v-html 解析htmlv-on 用来绑定事件监听器v-bind 动态更新html上的元素属性 修饰符.prevent 提交事件不再重载页面.stop 阻止单击事件冒泡.self 只当事件在该元素本身（不包括子元素）触发时触发回调.capture 添加事件监听器使用事件捕获模式.once 事件只能点击一次","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"vue日记01","slug":"vue日记01","date":"2019-07-01T12:27:29.000Z","updated":"2019-07-09T15:37:34.121Z","comments":true,"path":"2019/07/01/vue日记01/","link":"","permalink":"http://www.hefang.site/2019/07/01/vue日记01/","excerpt":"","text":"vue日记01条件渲染v-if控制切换一个元素是否显123456&lt;div v-if=isActive&gt;&lt;/div&gt;&lt;div v-else&gt;&lt;/div&gt;data:&#123; isActive:true&#125; 数据与方法当一个Vue实例被创建的时候，它的data里面所有的数据都会被加入到Vue相应系统中，如果data里面的值发生改变，视图也会产生相应的改变，将值更新为最新的12345var data = &#123;a:1&#125;var vm = new Vue(&#123; data:data&#125;)data.a = vm.a 设置a的值也会影响到原始数据（data），反之也是一样12vm.a = 2data.a = 2 所以当数据发生改变的时候，视图会进行重新渲染，只有在实例在被创建时data中存在的属性才是响应式的，比如说添加一个新的属性1data.b = 10 那么b的值的更新并不会触发任何视图的更新 特殊：Object.freeze() 它会阻止修改现有的属性，响应式无法在追踪变化123456789101112131415var fn = &#123; a:1&#125;Objectfreezz(fn)var app = new Vue(&#123; el:&quot;#app&quot;, data:fn &#125;&#125;)&lt;div id=&quot;app&quot;&gt; &lt;button @click=noChange&gt;&lt;/button&gt;&lt;/div&gt; 当点击按钮时候fn不会更新 watch1234567891011var value = &#123;a:1&#125;var app = new Vue(&#123; el:&quot;#app&quot;, data:value&#125;)app.$data === valueapp.$el === document.getElementById(&apos;app&apos;)app.$watch(&apos;a&apos;,function(newValue,oldvalue)&#123; // 这个回调将在 `vm.a` 改变后调用 &#125;) 生命周期钩子每一个Vue实例被创建的时候都要经过一系列初始化的过程，需要设置数据监听，编译模板，将实例挂在到DOM上且在数据改变的时候更新DOM，同时在这一过程中也会运行一些生命周期钩子的函数生命周期钩子的this上下文指向调用它的Vue实例","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"js基本知识","slug":"js基本知识","date":"2019-06-23T14:27:29.000Z","updated":"2019-06-24T15:15:59.603Z","comments":true,"path":"2019/06/23/js基本知识/","link":"","permalink":"http://www.hefang.site/2019/06/23/js基本知识/","excerpt":"","text":"JavaScript 定义了几种数据类型? 哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么?1.JavaScript 定义了几种数据类型? 一共有6种，分别是： 数值(number)：整数和小数；字符串(string)：字符组成的文本；布尔值(boolean)：true（真），flase（假）；underfined：表示未定义，不存在。null：空值，但不代表不存值。对象（object）：各种值的组合集合； 2.哪些是原始类型?数值，字符串，布尔值，称为原始类型的值，也叫基本类型。即它们是最基本的数据类型，不能再细分。 3.哪些是复杂类型？对象就是复杂类型，也叫做引用类型，因为对象往往是多个原始类型的值的合成，可以看作是一个存放各种值得容器。 对象细分为: 侠义的对象。 数组（Array） 函数（function） 正则表达式 ps：underfined和null一般看作是两个特殊的值。 4.原始类型和复杂类型有什么区别？ 基本类型一般存放于栈内存，是一个单一的值。 引用类型存放于堆内存中。用一个变量，放在栈内存中，指明它的地址。是一个包含各种值得容器。 typeof和instanceof的作用和区别? typeof： 一般用来检测基本类型是什么类型，例如：123``` 得到的值就是```number```。可是如果检测引用类型的话就会返回```object```，不能明确区分到底是```&#123;&#125;``` 还是数组```[]```。(检测函数的时候会返回```funtion```)123456789ps：```typeof null``` 是```object```，```typeof underfined``` 得到的是```underfined```。- instanceof：用来检测对象到底是数组```[]```，还是```&#123;&#125;```。### 如何判断一个变量是否是数字、字符串、布尔、函数?&gt; ```typeof 123 //number 'hello'link1```typeof true //boolean f()&#123;&#125; typeof flink12345678### NaN是什么? 有什么特别之处?- NaN本身是一个Number，基本类型。（我是一个数据类型，但是我不是一个有效的数据！！！！！！！！！！！！）- NaN含义是Not a Number，表示非数字，NaN和任何值都不相等，包括自己。### 如何把非数值转化为数值?- parseInt() （如果遇到小数点，会把小数向下约等于，转换为整数。 ）```parseInt(&apos;123&apos;) // 123 // 3```12- parseFloat() （如果遇到小数，会保留小数，转换为数据类型。）``` parseFloat(&apos;3.4&apos;) // 3.4 ==与===有什么区别? ==： 是近似等于。 == 在比较的时候可以转自动换数据类型 ===： 是绝对等于。 === 严格比较，不会进行自动转换，要求进行比较的操作数必须类型一致，不一致时返回flase。 break与continue有什么区别？ break是立即跳出循环。 continue 是跳出本次循环。执行下次循环。 void 0 和 undefined在使用场景上有什么区别? void 会执行后面的表达式并返回 undefined，是一个纯正的undefined； underfined可以在局部作用域被赋值，复写。","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"string Array方法总结","slug":"string Array方法总结","date":"2019-06-23T12:27:29.000Z","updated":"2019-06-23T15:29:37.813Z","comments":true,"path":"2019/06/23/string Array方法总结/","link":"","permalink":"http://www.hefang.site/2019/06/23/string Array方法总结/","excerpt":"","text":".toUpperCase() 变成大写123var a=&quot;string&quot;var b=a.toUpperCase()console.log(b)//&quot;STRING&quot; .toLowerCase() 变成小写123var a=&quot;STRING&quot;var b=a.toLowerCase()console.log(b)//&quot;string&quot; .split() 以括号里面的内容为分界点，让字符串变为数组1234567891011121314例子1：var a=&quot;string-ing&quot;var b=a.split(&quot;-&quot;)console.log(b)//[&quot;string&quot;,&quot;ing&quot;]例子2：var a=&quot;string&quot;var b=a.split()//可以不写东西console.log(b)//[&quot;string&quot;]例子3var a=&quot;string&quot;var b=a.split(&quot;&quot;)console.log(b)//[&quot;s&quot;, &quot;t&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;]; .join() 让数组以括号里面的内容合并成一个字符串12345678var a=[1,2,3,4,5,6]var b=a.join(&quot;&quot;)console.log(b)//123456例子2：var a=[1,2,3,4,5,6]var b=a.join()console.log(b)//1,2,3,4,5,6 substr() 获取字符串指定的部分123456var a=&quot;string&quot;var b=a.substr(1,2)//获取了从1开始的后面2个字符串，包括1////如果省略第二个参数，会自动获取到最后console.log(b)//trconsole.log(a)//&quot;string&quot; 这个方法不会对原字符串做出任何修改 substring() 获取字符串指定的部分123456var a=&quot;string&quot;var b=a.substring(1,2)//获取了从1开始的后面2个字符串，这个不包括1//如果省略第二个参数，会自动获取到最后console.log(b)//jconsole.log(a)//&quot;string&quot; 这个方法不会对原字符串做出任何修改 reverse()把数组翻转123var a=[1,2,3,4,5];var b=a.reverse()console.log(b)//[5,4,3,2,1] toString//把数组变成字符串，就用逗号隔开123var a=[1,2,3,4,5,6]var b=a.toString()console.log(b)//1,2,3,4,5,6 splice() 切取数组的值（会改变原来的数组）1234var a=[1,2,3,4,5,6]var b=a.splice(0,1,2)//从0开始索引，窃取1位数，会包括0，然后把窃取的位置添加2console.log(b)//[1]console.log(a)//[2,2,3,4,5,6] slice()窃取数组的元素，不会改变原数组。1234var a=[1,2,3,4,5,6]var b=a.slice(0,3)包括第0位，从第0位开始窃取后面的三个元素。不会改变原数组console.log(b)//[1,2,3]console.log(a)//[1,2,3,4,5,6] push() / pop() 从数组后面添加元素 / 从数组后面删除元素 （都会改变原数组）12345var a=[1,2,3,4,5,6]a.push(7)console.log(a)//[1,2,3,4,5,6,7]a.pop()console.log(a)//[1,2,3,4,5,6] unshift() / shift() 从数组前端添加元素 / 从数组前端删除元素 （都会改变原数组）12345var a=[1,2,3,4,5,6]a.unshift(7)console.log(a)//[7,1,2,3,4,5,6]a.shift() console.log(a)//[1,2,3,4,5,6]","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"正则表达式汇总","slug":"正则表达式汇总","date":"2019-06-22T10:27:29.000Z","updated":"2019-06-22T14:30:14.944Z","comments":true,"path":"2019/06/22/正则表达式汇总/","link":"","permalink":"http://www.hefang.site/2019/06/22/正则表达式汇总/","excerpt":"","text":"1.正则表达式一般命名为regex2.JS正则表达式常用的方法12345RegExpObject.test(string) //方法用于检测一个字符串是否匹配某个模式.stringObject.match(regexp) //方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配RegExpObject.exec(string) //方法用于检索字符串中的正则表达式的匹配。 方法举例12345let regex = /\\d/let str = 123123let str2 = &apos;cwh&apos;regex.test(str) //trueregex.test(str2)//false 123var regex = /(\\d&#123;4&#125;)\\S(\\d+)[-](\\d+)/var str = &apos;2017-1-12&apos;str.match(regex) // [&apos;2017&apos;,&apos;2017&apos;,&apos;1&apos;,&apos;12&apos;] 123var regex = /\\d/var str = 123123123regex.exec(str) // [1],[2],[3],[1]...[null],[1].... 3.常用限定符号 代码语法 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或者1次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 4.常用元字符 代码语法 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 5.常用的反义代码 代码语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这个几个字母以外的任意字符 6.编辑器如何用正则 代码解析 匹配div 匹配任意的空白符 匹配class 保留div 保留class 直接替换掉空格 注意： 有时候替换符是/1 又或者是 $","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"css常见样式","slug":"解析白屏和FOUC","date":"2019-06-11T14:11:29.000Z","updated":"2019-06-11T15:36:14.111Z","comments":true,"path":"2019/06/11/解析白屏和FOUC/","link":"","permalink":"http://www.hefang.site/2019/06/11/解析白屏和FOUC/","excerpt":"","text":"解析白屏和FOUC白屏：1.css导致 如果把样式放在底部，对于IE浏览器，某些场景下（打开新的窗口，刷新页面）时会出现白屏，而不是逐步展现内容； 如果使用@import标签，即使CSS放在头部，用link引入，也有可能出现白屏。 白屏产生的原因和浏览器的渲染机制有关，在painting之前的步骤上有时间的延迟，主要是CSS加载的延迟。 2.js导致： 把JS放在顶部可能会导致白屏。 对于图片和CSS，在加载时会并发加载（如同个域名下同时加载两个文件），但在加载JS时，会禁用并发（脚本会阻塞后面内容的呈现几后面组件的加载），所以把JS放在页面顶部会导致白屏现象。 FOUC： FOUC（Flash Of Unstyled Content，文档样式闪烁）, 产生的原因：如果把css放在底部，对于IE浏览器，对于某些场景，就会出现FOUC现象，对于firfox会一直表现FOUC， 解决办法：把link放在头部。 把@import换成link引入","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"深拷贝函数","slug":"深拷贝函数","date":"2019-05-29T12:27:29.000Z","updated":"2019-05-29T13:44:59.187Z","comments":true,"path":"2019/05/29/深拷贝函数/","link":"","permalink":"http://www.hefang.site/2019/05/29/深拷贝函数/","excerpt":"","text":"第一种:function copy(obj){ var newObject={}; for (var key in obj) { if(typeof obj[key] === &apos;number&apos;||typeof obj[key] === &apos;boolean&apos;||typeof obj[key] === &apos;string&apos;||obj[key] ===undefined||obj[key] === null){ newObject[key]=obj[key]; } else{ newObject[key]=copy(obj[key]) } } return newObject; } 第二种:var cloneObj = JSON.parse(JSON.stringify(obj));","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"css常见样式2","slug":"css常见样式2","date":"2019-05-26T10:27:29.000Z","updated":"2019-05-26T11:02:37.241Z","comments":true,"path":"2019/05/26/css常见样式2/","link":"","permalink":"http://www.hefang.site/2019/05/26/css常见样式2/","excerpt":"","text":"1.text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中 作用在行内元素上，实现行元素居中。 2. IE盒子模型和W3C盒子模型有什么区别？ IE 的盒子模型content 中包含了border和padding W3C的盒子模型content是不包括border和padding的 3、 { box-sizing: border-box;}的作用是什么？ 转换为IE的盒子模型，就是内容包括了border和padding{ box-sizing: content-box;}的作用是什么？ 默认值了，就是普通的W3C盒子模型。 4.line-height: 2和line-height: 200%有什么区别? line-height: 200%：当前字体尺寸的百分之两百设置行间距。 line-height: 2： 数字会与当前的字体尺寸相乘来设置行间距。 5.inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? inline-block：对象为内联对象，但是对象的内容可以作为块对象操作。(简单认为，可以设置大小的内联元素) 如何去除缝隙： 1.你可以把标签与标签之间的空格全部删除，但是这样不美观。2.在父元素设置，font-size：0；然后在你想设置的元素上再重新设置font-size：；(简单点说就是将空白字符的高度都设置为0)；3.高度不一样的inline-block元素如何顶端对齐：vertical-align: top; 6.CSS sprite 是什么? 简称雪碧图 你上去淘宝看看那些一个一个的icon就是雪碧图 优点：减少网页的http请求，从而大大的提高页面的性能 7.让一个元素”看不见”有几种方式？有什么区别? 方法 区别 opacity：0； 改变了透明度，让你看不见了。 还存在 display: none; 会让选中的元素直接删除； visibility：hidden； 类似于 opacity 还存在 background：rbga(0，0，0，0.2) 也是改变背景颜色，和透明度 还存在","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"css常见样式","slug":"css常见样式","date":"2019-05-24T14:10:29.000Z","updated":"2019-05-24T14:44:36.941Z","comments":true,"path":"2019/05/24/css常见样式/","link":"","permalink":"http://www.hefang.site/2019/05/24/css常见样式/","excerpt":"","text":"1.块级元素和行内元素分别有哪些？块级元素：div，h1~h6，table，form，header， footer，nav，ul，li，ol，dl。。。。。行内元素：a，input，span，i，img，strong， select。。。。。 2.动手测试并列出4条以上的特性区别。 块级元素 行内元素 没有设置宽度的情况下，默认占据一整行 内容有多宽，我就有多宽 可以随便设置宽高 不可以 随便设置padding，margin padding和margin只可以设置左右 可以包裹块级元素，行内元素 我只能包裹文本，和行内元素 3.什么是 CSS 继承? 哪些属性能继承，哪些不能？CSS继承，就是子元素继承了父元素的属性。 能继承 不能继承 letter-spacing height word-spacing min-height white-space max-height line-height width color min-width font max-width font-style float font-family position text-align overflow text-indent vertical-align font-weight clear 等等等等 等等等等 4.如何让块级元素水平居中？如何让行内元素水平居中?块级元素水平居中：margin：0 auto；行内元素水平居中：text-align：center； 5.单行文本溢出加…….如何实现？E{white-space:nowrap;overflow:hidden;text-overflow;} 6.px, em, rem 有什么区别 px：固定尺寸； em： 相对于当前对象内文本的字体尺寸 rem： 相对于HTML的相对大小 7.解释下面代码的作用?为什么要加引号? 字体里\\5b8b\\4f53代表什么?body{ font: 12px/1.5 tahoma,arial,’Hiragino Sans GB’,’\\5b8b\\4f53’,sans-serif;} 1.设置body字体大小为12px，行高是字体1.5倍的像素值，后面则是第一到第五字体，用逗号隔开，如果第一个你电脑没有，则运行第二个。2.加引号是因为，字体间有空格，这样会识别为不同的两个单词，所以加空格。3.字体那些代码代表“宋体” ps:在浏览器console里输入escape（”你想要的字体编码”），就能出现像想要的代码记住将%u改成/。","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"flex","slug":"flex","date":"2019-05-22T10:27:29.000Z","updated":"2019-05-22T12:23:42.002Z","comments":true,"path":"2019/05/22/flex/","link":"","permalink":"http://www.hefang.site/2019/05/22/flex/","excerpt":"","text":"flex在学习flex只是之前，平时的demo中使用到的传统布局主要有以下几种： 1、normal flow 文档流、正常流2、float + clear 清除浮动3、position relative + absolute 相对 + 绝对定位4、display inline-block 横向布局5、负 margin 扩大宽度、产生位移 这些传统的布局方式虽然可以满足我们的很多需求，但是也并不方便，比如实现垂直居中。而现在我们就要开始接触flex布局这种新的布局方式了。flex也可称为“弹性布局”，flex布局有以下几个特点： 1、块级布局侧重垂直方向，行内布局侧重水平方向。flex布局与方向无关2、flex布局可以实现空间自动分配，自动对齐3、flex布局适用于简单的线性布局，复杂的布局则可以使用grid布局 接下来就将对flex布局的几个重要知识点进行归纳。 flex布局的基本概念采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）。 flex container 的属性flex container（flex容器）有如下六个属性：flex-direction,flex-wrap,flex-flow,jstify-content,align-items,align-content flex-direction 方向-属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。该属性主要有以下值：row,row-reverse,column,column-reverse, 以flex-direction:row-reverse为例： https://jsbin.com/kugepiposa/edit?html,css,output flex-wrap 指定 flex 元素单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。该属性主要有以下值： wrap,nowrap,wrap-reverse, 以flex-wrap:wrap;为例： https://jsbin.com/pugumitoli/1/edit?html,css,output flex-flow 上面两个属性的缩写默认值为row nowrap，可以以如下方法设定该属性： .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } justify-content 主轴方向的对齐方式space-between,space-around,flex-start,flex-end,center以justify-content:space-between为例： https://jsbin.com/jowuvubiju/1/edit?html,css,output align-items 侧轴方向的对齐方式stretch,flex-start,flex-end,center,baseline 以align-items:center为例： https://jsbin.com/pebevizeri/1/edit?html,css,output align-content 多行多列的对齐方式space-between，space-around，flex-start，flex-end，stretch， flex item 的属性flex item（子元素）有如下六个属性： order flex-grow flex-shrink flex-basis flex align-self flex-grow该属性默认值为0。如果所有子元素的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个子元素的flex-grow属性为2，其他子元素都为1，则前者占据的剩余空间将比其他项多一倍。 例子： https://jsbin.com/vayolutake/1/edit?html,css,output flex-shink 空间不足时的收缩比例该属性默认值为1。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 例子： https://jsbin.com/deriqobuwu/1/edit?html,css,output、 flex-basis 子元素的默认宽度flex-basis属性定义了在分配多余空间之前，子元素占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来宽度。 例子： https://jsbin.com/vivuserebe/1/edit?html,css,output 使用flex布局的几个技巧flex 布局可以简便、完整、响应式地实现各种页面布局。下面就简要地记录几个flex布局的技巧 实现手机布局如果内容被修剪，需要浏览器显示滚动条，以便查看剩余内容，可以使用 over-flow:auto;实现手机上中下布局： .content{ height:100vh; display:flex; flex-direction:column; } 实现电脑左中右布局 .content&gt;aside{width:120px;} .content&gt;main{height:400px;flex:1} .content&gt;nav{width:100px;} 完美居中 .parent{ display:flex; justify-content:center; align-items:center; }","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"常见排序算法","slug":"常见排序算法","date":"2019-05-21T06:51:00.000Z","updated":"2019-05-22T04:09:31.898Z","comments":true,"path":"2019/05/21/常见排序算法/","link":"","permalink":"http://www.hefang.site/2019/05/21/常见排序算法/","excerpt":"","text":"常见排序算法 - 冒泡排序 (Bubble Sort)冒泡排序算法的流程如下：1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3、针对所有的元素重复以上的步骤，除了最后一个。4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实例分析：以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：第一次外循环 ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置 ( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置 ( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置 ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列） ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变 ( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置 ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) JavaScript 语言实现function bubbleSort(array) { var length = array.length, i, j, temp; for (i = length - 1; 0 &lt; i; i--) { for (j = 0; j &lt; i; j++) { if (array[j] &gt; array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } return array; } 流程图预览地址 常见排序算法 - 选择排序 (Selection Sort)算法原理选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 实例分析：以数组 arr = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）： min ↓ 8 5 2 6 9 3 1 4 0 7 ↑ ↑ └───────────────────────────────┘ 交换后： 0 5 2 6 9 3 1 4 8 7 在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换： min ↓ 0 5 2 6 9 3 1 4 8 7 ↑ ↑ └───────────────────┘ 交换后： 0 1 2 6 9 3 5 4 8 7 在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）： min ↓ 0 1 2 6 9 3 5 4 8 7 ↑ 重复上述过程，直到最后一个元素就完成了排序。 min ↓ 0 1 2 6 9 3 5 4 8 7 ↑ ↑ └───────┘ min ↓ 0 1 2 3 9 6 5 4 8 7 ↑ ↑ └───────────┘ min ↓ 0 1 2 3 4 6 5 9 8 7 ↑ ↑ └───┘ min ↓ 0 1 2 3 4 5 6 9 8 7 ↑ min ↓ 0 1 2 3 4 5 6 9 8 7 ↑ ↑ └───────┘ min ↓ 0 1 2 3 4 5 6 7 8 9 ↑ min ↓ 0 1 2 3 4 5 6 7 8 9 ↑ JavaScript 语言实现function selectionSort(array) { var length = array.length, i, j, minIndex, minValue, temp; for (i = 0; i &lt; length - 1; i++) { minIndex = i; minValue = array[minIndex]; for (j = i + 1; j &lt; length; j++) { if (array[j] &lt; minValue) { minIndex = j; minValue = array[minIndex]; } } // 交换位置 temp = array[i]; array[i] = minValue; array[minIndex] = temp; } return array } 流程图预览地址","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"grid","slug":"grid","date":"2019-05-21T03:27:29.000Z","updated":"2019-05-23T04:24:38.699Z","comments":true,"path":"2019/05/21/grid/","link":"","permalink":"http://www.hefang.site/2019/05/21/grid/","excerpt":"","text":"grid网格布局可以将应用程序分割成不同的空间，定义它们的大小、位置和层级。 简单来说，网格布局就像表格一样可以让元素按列和行对齐排列，不同的是，网格布局没有内容结构，比如一个网格布局的子元素可以定位自己的位置，可以是实现类似定位的效果。 兼容性caniuse可以看到几大浏览器都已经支持了Grid布局 grid vs flex我们知道flex和grid都是css3新的布局方式，如果浏览器都支持两种布局，你会选择那种呢？当我们了解两者以后就能做出正确的选择了。 flex布局是一维布局，grid布局是二维布局。 Grid属性分为两类，一类作用于grid容器，一类作用于grid子项目上。属性繁多，按需选用。 作用于grid容器 grid-template-columns grid-template-rows grid-template-areas grid-template grid-column-gap grid-row-gap grid-gap justify-items align-items place-items justify-content align-content place-content grid-auto-columns grid-auto-rows grid-auto-flow grid作用于grid子项目作用于grid子项目 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self place-self 举例几种布局：1、左右固定，中间自适应预览地址 2、九宫格预览地址 大多数网站布局预览地址 总结来说： CSS Grid 是一个二维的布局系统CSS Grid 相比传统布局在页面整体划分布局上更加出色CSS Grid 并不是只能单独使用，依然可以搭配Flexbox以及传统定位布局一起使用","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"原型与原型链","slug":"原型与原型链","date":"2018-12-11T02:44:29.000Z","updated":"2019-05-22T04:09:13.949Z","comments":true,"path":"2018/12/11/原型与原型链/","link":"","permalink":"http://www.hefang.site/2018/12/11/原型与原型链/","excerpt":"","text":"例子1function Person(name){ this.name = name; this.age = age; } Person.prototype.sayName = function(){ console.log(this.name); } var p1 = new Person(&apos;a&apos;); var p2 = new Person(&apos;b&apos;); p1.sayName(); p2.sayName(); 1.new 一个函数本质上做了什么？ 1)创建了一个空的对象 2)空对象的proto指向了类Modal()的prototype 3)在执行函数的过程中，给this赋值，函数里的this代表了空对象，返回出去 4)将this赋值给modal2.通过函数定义了一个类Person，它自动获取了属性prototype，每个类的实例也就是p1、p2内部都会有一个proto的属性，如下图: 例子2当前的p1实例，查找toString()的方法先从p1的属性里找，没有找到,再从 p1.proto 中找，没有找到,再从 p1.proto.proto 中找，找到后返回 例子3function People(){} var p = new People() p.__proto__ === People.prototype People.__proto__ === Function.prototype People.prototype.__proto__ === Object.prototype （1）People函数创建了对象 p，所以People.prototype === p.proto；（2）Object函数创建了People.prototype对象，所以Object.prototype === People.prototype.proto；（3）People 作为对象的角色被函数Function创建，所以 Function.prototype === People.proto; 例子4（1）任何函数都是 Function 创建，所以Function 创建了 Function，所以 Function.prototype === Function.proto；（2）Object 也是函数。所以Function创建了Object，所以 Function.prototype === Object.proto ；（3）Function.prototype 是普通对象，普通对象是由Object创建的，所以 Function.prototype.proto === Object.prototype 例子5Object instanceof Function Function instanceof Object Function instanceof Function Object instanceof Object instanceof的作用是判断一个对象是不是一个函数的实例。比如obj instanceof fn,实际上是判断fn的prototype是不是在obj的原型链上。比如: obj.__proto__ === fn.prototype obj.__proto__.__proto__ === fn.prototype obj.__proto__..._proto__ === fn.prototype 只要一个成立即可。1.对于Function instanceof Function,因为 Function.proto === Function.prototype所以为true。 2.对于Object instanceof Object,因为 Object.proto.proto === Function.prototype.proto === Object.prototype,所以为true 3.对于Function instanceof Object,因为 Function.proto.proto === Function.prototype.proto === Object.prototype,所以为true 4.对于Object instanceof Function,因为 Object.proto === Function.prototype所以为true","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"动画队列","slug":"动画队列","date":"2018-10-26T10:27:29.000Z","updated":"2019-05-22T04:09:09.298Z","comments":true,"path":"2018/10/26/动画队列/","link":"","permalink":"http://www.hefang.site/2018/10/26/动画队列/","excerpt":"","text":"动画队列jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。 .stop( [clearQueue ] [, jumpToEnd ] )（添加版本1.2）clearQueue类型: Boolean一个布尔值，指示是否取消以列队动画。默认 false.jumpToEnd类型: Boolean一个布尔值指示是否当前动画立即完成。默认false. .stop( [queue ] [, clearQueue ] [, jumpToEnd ] )（添加版本1.7）queue类型: String停止动画队列的名称。clearQueue类型: Boolean一个布尔值，指示是否取消以列队动画。默认 false.jumpToEnd类型: Boolean一个布尔值指示是否当前动画立即完成。默认false.jQuery中有stop这个方法可以停止当前执行的动画，并且它有两个布尔参数，默认值都为false。 clearQueue(default: false) jumpToEnd(default: false) 第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以，我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后面的队列丢弃了，这就会出现意料之外的结果。 ###我们可以看到如下整理结果: 方法 参数 说明 stop() 清空队列，当前执行动作立即停止。后续动作会不再执行。 等同于：stop(false,false) stop(true) [clearQueue] 清空队列，当前执行动作立即停止。后续动作会不再执行 stop(true,true) [clearQueue],[gotoEnd] 清空队列，当前执行动作立即完成。后续动作会不再执行 stop(true,false) [clearQueue],[gotoEnd] 清空队列，当前执行动作立即停止。后续动作会不再执行 stop(false) [clearQueue] 不清空队列，当前执行动作立即停止。后续动作会立即执行 stop(false,true) [clearQueue],[gotoEnd] 不清空队列，当前执行动作立即完成。后续动作会立即执行 stop(false,false) [clearQueue],[gotoEnd] 不清空队列，当前执行动作立即停止。后续动作会立即执行","categories":[{"name":"jquery","slug":"jquery","permalink":"http://www.hefang.site/categories/jquery/"}],"tags":[]},{"title":"CORS","slug":"跨域(CORS)","date":"2018-10-02T08:27:29.000Z","updated":"2019-05-22T04:09:43.265Z","comments":true,"path":"2018/10/02/跨域(CORS)/","link":"","permalink":"http://www.hefang.site/2018/10/02/跨域(CORS)/","excerpt":"","text":"cors为什么要跨域？跨域问题是浏览器同源策略限制，当前域名的js只能读取同域下的窗口属性。一个网站的网址组成包括协议名，子域名，主域名，端口号。比如 https://www.github.com/80，其中https是协议名,www.github.com是子域名，github.com是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在http://localhost:80/ 页面请求http://127.0.0.1:80 也会有跨域问题（因为域名不一样嘛~） 跨域的实现的几种方式1、Jsonp最常见的一种跨域方式，其背后的原理就是利用script标签不受同源策略的限制，在页面中动态插入script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理的函数名名告诉后端，后端在响应请求时会将函数回调返回，并且将数据以参数的形式传递回去代码部分： &lt;script&gt; function showData(ret){ console.log(ret); } &lt;/script&gt; 2、CORS当使用XMLHttpRequest发送请求是，如果浏览器发现了违反了同源策略就会自动加上一个请求头：origin，后端在接受请求的时候确定响应后会在Response Headers中加入一个熟悉：Access-Control-Allow-Origin，value就是发起请求的源地址 http://127.0.0.1:8080，浏览器得到响应会继续判断Access-Control—Allow—Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理 var http = require(&apos;http&apos;) var fs = require(&apos;fs&apos;) var path = require(&apos;path&apos;) var url = require(&apos;url&apos;) http.createServer(function(req,res){ var pathObj = url.parse(req.url,true) switch(pathObj.pathname){ case &apos;/getWeather&apos;: var weather =[ &quot;beijing&quot;:&quot;sunny&quot;, &quot;shanghai&quot;:&quot;cloudy&quot; ] res.setHeader(&apos;Access-Control-Allow-Origin&apos;,http://localhost:8080) res.end(JSON.stringify(weather)) break; default: fs.readFile(parse.join(__dirname,pathObj.pathname),function(e,data){ if(e){ res.writeHead(404, &apos;not found&apos;) res.end(&apos;&lt;h1&gt;404 not found&lt;/h1&gt;&apos;) }else{ res.end(data) } }) } }).listen(8080) $(&apos;.change&apos;).addEventListener(&apos;click&apos;, function () { var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, &apos;http://localhost:8080/getWeather&apos;, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { appendHtml(JSON.parse(xhr.responseText)) } }; }); 2、window.postMessage(message,targetOrigin)方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。这种方法不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据","categories":[{"name":"http","slug":"http","permalink":"http://www.hefang.site/categories/http/"}],"tags":[]},{"title":"cookie&session&localStorage","slug":"cookie&session&localStorage","date":"2018-09-15T12:27:29.000Z","updated":"2019-05-26T10:58:34.360Z","comments":true,"path":"2018/09/15/cookie&session&localStorage/","link":"","permalink":"http://www.hefang.site/2018/09/15/cookie&session&localStorage/","excerpt":"","text":"cookie&amp;session&amp;localStorage一、cookiecookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。在控制台用 「document.cookie」查看你当前正在浏览的网站的cookie。cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用 HTTP 协议规定的 set-cookie 来让浏览器种下cookie，这是最常见的做法。（打开一个网站，清除全部cookie，然后刷新页面，在network的Response headers试试找一找set-cookie吧）每次网络请求 Request headers 中都会带上cookie。所以如果 cookie 太多太大对传输效率会有影响。一般浏览器存储cookie 最大容量为4k，所以大量数据不要存到cookie。设置cookie时的参数：path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。expires 和 maxAge：告诉浏览器 cookie 时候过期，maxAge 是 cookie 多久后过期的相对时间。不设置这两个选项时会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。[cookie 参数][简述 Cookie 是什么] 二、session当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个session用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。创建session后，会把关联的session_id 通过setCookie 添加到http响应头部中。浏览器在加载页面时发现响应头部有 set-cookie字段，就把这个cookie 种到浏览器指定域名下。当下次刷新页面时，发送的请求会带上这条cookie， 服务端在接收到后根据这个session_id来识别用户。cookie 是存储在浏览器里的一小段「数据」，而session是一种让服务器能识别某个用户的「机制」，session 在实现的过程中需要使用cookie。当然有时候说到 session 也指服务器里创建的那个和用户身份关联的对象。 三、localStoragelocalStorage HTML5本地存储web storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。不参与网络传输。一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"HTMLCollection 和 NodeList","slug":"HTMLCollection 和 NodeList","date":"2018-09-04T10:27:29.000Z","updated":"2019-05-22T04:11:15.493Z","comments":true,"path":"2018/09/04/HTMLCollection 和 NodeList/","link":"","permalink":"http://www.hefang.site/2018/09/04/HTMLCollection 和 NodeList/","excerpt":"","text":"HTMLCollection 和 NodeList节点都是单个对象，有时会需要一种数据结构，能够容纳多个节点。DOM提供两种集合对象，用于实现这种节点的集合：NodeList和HTMLCollection。 NodeList 对象代表一个有顺序的节点列表，HTMLCollection 是一个接口，表示 HTML 元素的集合，它提供了可以遍历列表的方法和属性 以下方法获取的为HTMLCollection对象 document.images //所有img元素 document.links //所有带href属性的a元素和area元素 document.forms //所有form元素 document.scripts //所有script元素 document.body.children document.getElementsByClassName(&quot;class1&quot;) 以下方法获取的为NodeList对象 document.getElementsByName(&quot;name1&quot;) document.getElementsByTagName(&quot;a&quot;) document.querySelectorAll(&quot;a&quot;) document.body.childNodes 如何查看？ document.body.childNodes.constructor HTMLCollection与NodeList基本相似 相同点： 都是类数组对象，节点的变化都会实时反映在集合中 不同点： 少部分方法不一样，比如 NodeList 有 forEach 方法，而 HTMLCollection 没有","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"随机生成ip、字符串、color","slug":"随机生成IP、字符串、颜色等","date":"2018-09-01T12:44:29.000Z","updated":"2019-05-22T04:09:52.683Z","comments":true,"path":"2018/09/01/随机生成IP、字符串、颜色等/","link":"","permalink":"http://www.hefang.site/2018/09/01/随机生成IP、字符串、颜色等/","excerpt":"","text":"随机生成ip、字符串、color//随机生成32位字符串 function getRandomStr(len) { var a = &apos;&apos; var b =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot; for (i = 0 ; i &lt;len; i++){ var c = Math.floor(Math.random()*b.length) a += b[c] } return a } var a = getRandomStr(32) console.log(a) //随机生成一个IP地址 function getRandIP(){ var ip=[] for (i= 0 ; i&lt;4; i++){ ip[i]= Math.floor(Math.random()*256) } return ip.join(&apos;.&apos;) } var ip = getRandIP() console.log(ip) //生成一个随机颜色字符串 function getRandColor(){ var color = &apos;#&apos; var dict =&apos;0123456abcdef&apos; for(i = 0; i &lt; 6; i++){ var index =Math.floor(Math.random()*dict.length) color += dict[index] } return color } var color = getRandColor() console.log(color) //min到max之间的 随机整数 function sum(min,max){ var sum =Math.floor(Math.random()*(max-min))+min return sum } console.log(sum(1,100))","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"实现一个flatten函数","slug":"实现一个flatten函数","date":"2018-09-01T04:44:29.000Z","updated":"2019-05-22T04:09:22.563Z","comments":true,"path":"2018/09/01/实现一个flatten函数/","link":"","permalink":"http://www.hefang.site/2018/09/01/实现一个flatten函数/","excerpt":"","text":"实现一个flatten函数实现一个flatten函数，将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组，数组中元素仅基本类型的元素或数组，不存在循环引用的情况。 Ex: flatten([1, [2], [3, [[4]]]]) =&gt; [1, 2, 3, 4]; //方法1 var arr = ([1, [2], [3, [[4]]]]) function flatten(arr){ var newArr = [] function _flat(arr){ arr.forEach(val=&gt;{ if(Array.isArray(val)){ _flat(val) }else{ newArr.push(val) } }) } _flat(arr) return newArr } //方法2 var arr = ([1, [2], [3, [[4]]]]) function flatten2(arr){ return arr.reduce(function(initArr, currentArr){ return initArr.concat(Array.isArray(currentArr)?flatten2(currentArr):currentArr) }, []) } console.log(flatten2(arr)) //[1, 2, 3, 4]","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"JavaScript专题之数组扁平化","slug":"数组扁平化","date":"2018-08-31T02:44:29.000Z","updated":"2019-05-22T04:09:37.594Z","comments":true,"path":"2018/08/31/数组扁平化/","link":"","permalink":"http://www.hefang.site/2018/08/31/数组扁平化/","excerpt":"","text":"扁平化数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。 举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下： var arr = [1, [2, [3, 4]]]; console.log(flatten(arr)) // [1, 2, 3, 4] 知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了 递归我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法： // 方法 1 var arr = [1, [2, [3, 4]]]; function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) { if (Array.isArray(arr[i])) { result = result.concat(flatten(arr[i])) } else { result.push(arr[i]) } } return result; } console.log(flatten(arr)) toString如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为： [1, [2, [3, 4]]].toString() // “1,2,3,4”调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？ // 方法2 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.toString().split(&apos;,&apos;).map(function(item){ return +item }) } console.log(flatten(arr)) 然而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，这种方法就会产生错误的结果。 reduce既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码： // 方法3 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.reduce(function(prev, next){ return prev.concat(Array.isArray(next) ? flatten(next) : next) }, []) } console.log(flatten(arr)) …ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： var arr = [1, [2, [3, 4]]];console.log([].concat(…arr)); // [1, 2, [3, 4]]我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： // 方法4 var arr = [1, [2, [3, 4]]]; function flatten(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flatten(arr)) undercore那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~ 在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。 /** 数组扁平化 @param {Array} input 要处理的数组 @param {boolean} shallow 是否只扁平一层 @param {boolean} strict 是否严格处理元素，下面有解释 @param {Array} output 这是为了方便递归而传递的参数 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528*/ function flatten(input, shallow, strict, output) { // 递归使用的时候会用到output output = output || []; var idx = output.length; for (var i = 0, len = input.length; i &lt; len; i++) { var value = input[i]; // 如果是数组，就进行处理 if (Array.isArray(value)) { // 如果是只扁平一层，遍历该数组，依此填入 output if (shallow) { var j = 0, length = value.length; while (j &lt; length) output[idx++] = value[j++]; } // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output else { flatten(value, shallow, strict, output); idx = output.length; } } // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output else if (!strict){ output[idx++] = value; } } return output; } 解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子： var arr = [1, 2, [3, 4]];console.log(flatten(arr, true, true)); // [3, 4]那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果： shallow true + strict false ：正常扁平一层shallow false + strict false ：正常扁平所有层shallow true + strict true ：去掉非数组元素shallow false + strict true ： 返回一个[]我们看看 underscore 中哪些方法调用了 flatten 这个基本函数： _.flatten首先就是 _.flatten： _.flatten = function(array, shallow) { return flatten(array, shallow, false);};在正常的扁平中，我们并不需要去掉非数组元素。 _.union接下来是 _.union： 该函数传入多个数组，然后返回传入的数组的并集， 举个例子： _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);=&gt; [1, 2, 3, 101, 10]如果传入的参数并不是数组，就会将该参数跳过： _.union([1, 2, 3], [101, 2, 1, 10], 4, 5);=&gt; [1, 2, 3, 101, 10]为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。 // 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27) function unique(array) { return Array.from(new Set(array)); } _.union = function() { return unique(flatten(arguments, true, true)); } _.difference是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference： 语法为： _.difference(array, *others) 效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。 举个例子： _.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);=&gt; [1, 3]实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值： function difference(array, ...rest) { rest = flatten(rest, true, true); return array.filter(function(item){ return rest.indexOf(item) === -1; }) }","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"js作用域","slug":"js作用域相关介绍","date":"2018-08-27T15:27:29.000Z","updated":"2019-05-22T04:08:49.404Z","comments":true,"path":"2018/08/27/js作用域相关介绍/","link":"","permalink":"http://www.hefang.site/2018/08/27/js作用域相关介绍/","excerpt":"","text":"JavaScript的作用域是什么作用域，在维基百科上解释是：在电脑程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： (1）程序最外层定义的函数或者变量var a = “tsrot”;function hello(){ alert(a);} function sayHello(){ hello();} alert(a); //能访问到tsrothello(); //能访问到tsrotsayHello(); //能访问到hello函数，然后也能访问到tsrot（2）所有末定义直接赋值的变量（不推荐）function hello(){ a = “tsrot”; var b = “hello tsrot”;} alert(a); //能访问到tsrotalert(b); //error 不能访问（3）所有window对象的属性和方法一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。function hello(){ var a = “tsrot”; alert(a);} hello(); //函数内可访问到tsrotalert(a); //error not defined","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"浏览器的渲染机制","slug":"介绍浏览器的渲染机制","date":"2018-05-27T11:27:29.000Z","updated":"2019-05-22T04:29:48.977Z","comments":true,"path":"2018/05/27/介绍浏览器的渲染机制/","link":"","permalink":"http://www.hefang.site/2018/05/27/介绍浏览器的渲染机制/","excerpt":"","text":"浏览器的渲染机制首先当用户输入一个URL的时候，浏览器就会发送一个请求，请求URL对应的资源。然后浏览器的HTML解析器会将这个文件解析，并且构建成一棵DOM树。在构建DOM树的时候，遇到JS和CSS元素，HTML解析器就换将控制权转让给JS解析器或者是CSS解析器。JS解析器或者是CSS解析器解析完这个元素时候，HTML又继续解析下个元素，直到整棵DOM树构建完成。DOM树构建完之后，浏览器把DOM树中的一些不可视元素去掉，然后与CSSOM合成一棵render树。接着浏览器根据这棵render树，计算出各个节点(元素)在屏幕的位置。这个过程叫做layout，输出的是一棵layout树。最后浏览器根据这棵layout树，将页面渲染到屏幕上去。","categories":[{"name":"http","slug":"http","permalink":"http://www.hefang.site/categories/http/"}],"tags":[]},{"title":"cookie&session&localStorage","slug":"call&apply","date":"0201-06-15T12:21:46.000Z","updated":"2019-06-21T15:10:14.398Z","comments":true,"path":"0201/06/15/call&apply/","link":"","permalink":"http://www.hefang.site/0201/06/15/call&apply/","excerpt":"","text":"this &amp;&amp; arguments1234567function fn() &#123; console.log(this) console.log(arguments)&#125;fn() //window //[]//一般情况下 如果this 没有指定对象，那么就会指向全局 window//arguments 是代表实参，如果没有参数的传递 默认值就是一个伪数组 call this 为什么必须是对象因为 this 就是函数与对象之间的羁绊 123456789101112var person = &#123; name: &apos;frank&apos;, sayHi: function(person)&#123; console.log(&apos;Hi, I am&apos; + person.name) &#125;, sayBye: function(person)&#123; console.log(&apos;Bye, I am&apos; + person.name) &#125;, say: function(person, word)&#123; console.log(word + &apos;, I am&apos; + person.name) &#125; &#125; 看上面代码 我们通常会把person.name 改写成 this.name 但是如果JS里面 没有this 我们就只可以写成person.name，就像上面一样，这样写有一个好处，令阅读者更加清晰知道，你要打印出哪个name。 这样说，我们写代码就完成可以不用this。123456789101112131415161718192021222324252627//如果用this 我们会这样打印person.sayHi()person.sayBay()person.say(&apos;你好&apos;)//可是这样源码就要改变var person = &#123; name: &apos;frank&apos;, sayHi: function()&#123; console.log(&apos;Hi, I am&apos; + this.name) &#125;, sayBye: function()&#123; console.log(&apos;Bye, I am&apos; + this.name) &#125;, say: function(word)&#123; console.log(word + &apos;, I am&apos; + this.name) &#125; &#125;//如果不用this 我们可以这样打印person.sayHi(person)person.say(person)person.say(person,&apos;你好&apos;)//同样 我们可以用call 更清晰的打印person.sayHi.call(person)person.sayBay.call(person)person.say.call(person,&apos;你好&apos;) this 是call 的第一个参数 所以 我们在调用的时候 才能知道this 指向谁,所以this其实很不靠谱 我们还会经常疑惑的一种写法123var fn = person.sayHiperson.sayHi() // this === personfn() // this === window call 和 apply 的区别1234567891011121314function fn()&#123; var n = 0 for(var i = 0; i&lt;arguments.length; i++)&#123; n += arguments[i] &#125; return n&#125;//如果给出的参数是一个数组 而我们想数组的值相加//用call 就会有点鸡肋var a = [1,2,3,4,5]fn.call(null,a[0],a[1]....) //傻逼才会这样做//这时候我们就用applyfn.apply(null,a) //applay的第二参数是一个数组","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]}]}