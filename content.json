{"meta":{"title":"he'blog","subtitle":null,"description":null,"author":"何方","url":"http://www.hefang.site","root":"/"},"pages":[{"title":"关于","date":"2018-11-30T16:52:39.000Z","updated":"2019-05-22T01:43:49.942Z","comments":true,"path":"about/index.html","permalink":"http://www.hefang.site/about/index.html","excerpt":"","text":""},{"title":"归档","date":"2018-11-30T17:12:43.000Z","updated":"2019-05-22T04:20:31.527Z","comments":true,"path":"archives/index.html","permalink":"http://www.hefang.site/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-30T16:52:39.000Z","updated":"2019-05-22T01:42:21.441Z","comments":true,"path":"categories/index.html","permalink":"http://www.hefang.site/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2018-09-01T06:21:57.000Z","updated":"2019-05-22T01:43:15.717Z","comments":true,"path":"resources/index.html","permalink":"http://www.hefang.site/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-30T17:12:43.000Z","updated":"2019-05-22T01:42:14.097Z","comments":true,"path":"tags/index.html","permalink":"http://www.hefang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue日记06","slug":"vue日记06","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T14:43:21.025Z","comments":true,"path":"2019/07/03/vue日记06/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记06/","excerpt":"","text":"vue日记06列表渲染用 v-for 把一个数组对应为一组元素我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名v-for 还支持一个可选的第二个参数，即当前项的索引例子：1234567891011&lt;ul&gt; &lt;li v-for=&quot;(list,index)in lists&quot;&gt;&#123;&#123;list.value&#125;&#125;&lt;/li&gt;&lt;/ul&gt;data:&#123; lists:[ &#123;value:0&#125;, &#123;value:1&#125;, &#123;value:2&#125; ]&#125; 用 v-for 来遍历一个对象的属性例子：1234567891011121314151617181920&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;)渲染结果： How to do lists in Vue Jane Doe 2016-04-10 提供第二个的参数为 property 名称 (也就是键名)：例子：123456789101112131415161718&lt;div v-for=&quot;(value, name) in object&quot;&gt; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;)渲染结果： title: How to do lists in Vue author: Jane Doe publishedAt: 2016-04-10 提供第三个的参数作为索引:123456789101112131415161718&lt;div v-for=&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;)渲染结果： 0.title: How to do lists in Vue 1.author: Jane Doe 2.publishedAt: 2016-04-10 维护状态当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：1&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 变异方法 (mutation method)Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：push() 方法可以向数组的末尾添加一个或者多个元素，并返回新的长度pop() 删除并返回数组的最后一个元素shift() 删除shift并返回数组的第一个元素unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。sort() 对数组的元素进行排序reverse() 方法用于颠倒数组中元素的顺序。 替换数组变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 filter()、concat() 和 slice() 。它们不会改变原始数组，而总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。slice()方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 对象变更检测注意事项对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性例如，对于：1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &apos;Anika&apos; &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, &apos;age&apos;, 27) 或者：使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：1vm.$set(vm.userProfile, &apos;age&apos;, 27) 显示过滤/排序后的结果用计算属性来返回过滤或排序后的数组。123456789101112&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 用methods方法来返回过滤或排序后的数组。123456789101112&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 在 v-for 里使用值范围v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。 123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 在 上使用 v-for可以利用带有 v-for 的 来循环渲染一段包含多个元素的内容123456&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for 与 v-if 一同使用v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下:1234&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt;上面的代码将只渲染未完成的 todo 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 )上。如：123456&lt;ul v-if=&quot;todos.length&quot;&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 在组件上使用 v-for在自定义组件上，你可以像在任何普通元素上一样使用 v-for 。1&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt; 2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记08","slug":"vue日记08","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T14:46:56.626Z","comments":true,"path":"2019/07/03/vue日记08/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记08/","excerpt":"","text":"vue日记08表单输入绑定基础用法用 v-model 指令在表单input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理 v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件: text 和 textarea 元素使用 value 属性和input 事件 checkbox 和 radio 使用 checked 属性和change 事件 select 字段将 value 作为 prop 并将change 作为事件 文本 text12&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本 textarea1234&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt; 复选框单个复选框，绑定到布尔值：12&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，绑定到同一个数组：1234567891011121314151617&lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; checkedNames: [] &#125;&#125;) 单选按钮12345678910111213141516&lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; picked: &apos;&apos; &#125;&#125;) 选择框单选时:12345678910111213141516&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;&apos; &#125;&#125;) 多选时 (绑定到一个数组)：12345678910111213141516&lt;div id=&quot;example-6&quot;&gt; &lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-6&apos;, data: &#123; selected: [] &#125;&#125; 用 v-for 渲染的动态选项：1234567891011121314151617&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;A&apos;, options: [ &#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125; ] &#125;&#125;) 值绑定对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：12345678910&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;&lt;/select&gt; 但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串 修饰符.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记10","slug":"vue日记10","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T14:51:10.627Z","comments":true,"path":"2019/07/03/vue日记10/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记10/","excerpt":"","text":"vue日记10组件注册组件名大小写使用 kebab-case1Vue.component(&apos;my-component-name&apos;, &#123; /* ... */ &#125;) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如&lt;my-component-name&gt; 使用 PascalCase1Vue.component(&apos;MyComponentName&apos;, &#123; /* ... */ &#125;) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说&lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 全局注册12345678910Vue.component(&apos;component-a&apos;, &#123; /* ... */ &#125;)Vue.component(&apos;component-b&apos;, &#123; /* ... */ &#125;)Vue.component(&apos;component-c&apos;, &#123; /* ... */ &#125;)new Vue(&#123; el: &apos;#app&apos; &#125;)&lt;div id=&quot;app&quot;&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt; 局部注册1234567new Vue(&#123; el: &apos;#app&apos;, components: &#123; &apos;component-a&apos;: ComponentA, &apos;component-b&apos;: ComponentB &#125;&#125;) 在模块系统中局部注册1234567891011import ComponentA from &apos;./ComponentA&apos;import ComponentC from &apos;./ComponentC&apos;export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记09","slug":"vue日记09","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T14:49:12.336Z","comments":true,"path":"2019/07/03/vue日记09/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记09/","excerpt":"","text":"vue日记09组件基础基本示例123456789// 定义一个名为 button-counter 的新组件Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;&#125;) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：1234&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#components-demo&apos; &#125;) 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项 组件的复用你可以将组件进行任意次数的复用：12345&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建 data 必须是一个函数当我们定义这个 &lt;button-counter&gt; 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：12345data: function () &#123; return &#123; count: 0 &#125;&#125; 组件的注册全局注册:123Vue.component(&apos;my-component-name&apos;, &#123; // ... options ...&#125;) 局部注册:123456789var app = new vue(&#123; el:&quot;#app&quot;, data:&#123; ... &#125;, components:&#123; &apos;component-a&apos;: ComponentA, &#125;&#125;) 通过 Prop 向子组件传递数据Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性1234Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;title&apos;], template: &apos;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&apos;&#125;) 然而在一个典型的应用中，你可能在 data 里有一个博文的数组：12345678910new Vue(&#123; el: &apos;#blog-post-demo&apos;, data: &#123; posts: [ &#123; id: 1, title: &apos;My journey with Vue&apos; &#125;, &#123; id: 2, title: &apos;Blogging with Vue&apos; &#125;, &#123; id: 3, title: &apos;Why Vue is so fun&apos; &#125; ] &#125;&#125;) 并想要为每篇博文渲染一个组件：12345&lt;blog-post v-for=&quot;post in posts&quot; v-bind:key=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单个根元素将模板的内容包裹在一个父元素内1234567891011121314&lt;blog-post v-for=&quot;post in posts&quot; v-bind:key=&quot;post.id&quot; v-bind:post=&quot;post&quot;&gt;&lt;/blog-post&gt;Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;post&apos;], template: ` &lt;div class=&quot;blog-post&quot;&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt; &lt;/div&gt; `&#125;) 监听子组件事件父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件123456789&lt;blog-post ... v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt; methods:&#123; onEnlargeText(value)&#123; this.value = value &#125; &#125; 子组件可以通过调用内建的 $emit 方法 并传入事件名称来触发一个事件123&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;,value)&quot;&gt; Enlarge text&lt;/button&gt; 在组件上使用 v-model自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：1&lt;input v-model=&quot;searchText&quot;&gt; 等价于：123&lt;inputv-bind:value=&quot;searchText&quot;v-on:input=&quot;searchText = $event.target.value&quot;&gt; 当用在组件上时，v-model 则会这样：1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value 特性绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 写成代码之后是这样的：12345678Vue.components(&apos;custom-input&apos;,&#123; props：[&apos;value&apos;], template:` &lt;input :value=&quot;value&quot; @input=&quot;$emit(&apos;input&apos;,$event.target.value)&quot; &gt; `&#125;)渲染之后：&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 通过插槽分发内容123456789101112&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt;Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 动态组件通过 Vue 的 元素加一个特殊的 is 特性来实现12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记11","slug":"vue日记11","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T15:29:57.351Z","comments":true,"path":"2019/07/03/vue日记11/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记11/","excerpt":"","text":"vue日记11PropProp 的大小写 (camelCase vs kebab-case)HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名1234567Vue.component(&apos;blog-post&apos;, &#123; // 在 JavaScript 中是 camelCase 的 props: [&apos;postTitle&apos;], template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;)&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt; 注意：如果你使用字符串模板，那么这个限制就不存在了 Prop 类型123456789props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; 传递静态或动态 Prop1&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt; 你也知道 prop 可以通过 v-bind 动态赋值，例如：1234567&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title + &apos; by &apos; + post.author.name&quot;&lt;/blog-post&gt; 在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop 传入一个数字123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt; 传入一个布尔值123456789&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt; 传入一个数组123456&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:comment-ids=&quot;post.commentIds&quot;&gt;&lt;/blog-post&gt; 传入一个对象1234567891011&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:author=&quot;&#123; name: &apos;Veronica&apos;, company: &apos;Veridian Dynamics&apos; &#125;&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt; 传入一个对象的所有属性将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：123456post: &#123; id: 1, title: &apos;My Journey with Vue&apos;&#125;&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt; 等价于：1234&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单向数据流两种常见的试图改变一个 prop 的情形1.这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：123456props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 2.这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; Prop 验证为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：123456789101112131415161718192021222324252627282930313233Vue.component(&apos;my-component&apos;, &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 类型检查type 可以是下列原生构造函数中的一个： StringNumberBooleanArrayObjectDateFunctionSymbol 非 Prop 的特性一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记07","slug":"vue日记07","date":"2019-07-03T14:27:29.000Z","updated":"2019-07-11T14:45:31.464Z","comments":true,"path":"2019/07/03/vue日记07/","link":"","permalink":"http://www.hefang.site/2019/07/03/vue日记07/","excerpt":"","text":"vue日记07事件处理事件监听v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码1234567891011&lt;div id=&quot;example-1&quot;&gt; &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; counter: 0 &#125;&#125;) 事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。例子：123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;onClick&quot;&gt;Greet&lt;/button&gt;&lt;/div&gt;var app = new Vue(&#123; el：&quot;#app&quot;, data:&#123; age:25 &#125;, methods:&#123; onClick(even)&#123; alert(this.age) &#125; if(even) &#123; alert(even.target.tagName) &#125; &#125; &#125;) 内联处理器中的防范除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：12345678910111213&lt;div id=&quot;example-3&quot;&gt; &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt; &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) 事件修饰符Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的 .stop .prevent .capture .self .once .passive 按键码使用 keyCode 特性也是允许的： 1&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器 .ctrl .alt .shift .meta exact 修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 鼠标按钮修饰符修饰符会限制处理函数仅响应特定的鼠标按钮 .left .right .middle","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记05","slug":"vue日记05","date":"2019-07-02T14:27:29.000Z","updated":"2019-07-10T15:16:58.854Z","comments":true,"path":"2019/07/02/vue日记05/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记05/","excerpt":"","text":"vue日记05条件渲染v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。v-else你可以使用 v-else 指令来表示 v-if 的“else 块”：例子：1234567&lt;div&gt; &lt;div v-if=&quot;loading&quot;&gt;loading icon&lt;/div&gt; &lt;div v-else&gt;content&lt;/div&gt;&lt;/div&gt;data:&#123; loading:true&#125; v-else-if顾名思义，充当 v-if 的“else-if 块”，可以连续使用：1234&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;C&lt;/div&gt;&lt;div v-else&gt;Not A/B/C&lt;/div&gt; 用 key 管理可复用的元素官网例子：12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; 如果不增加key的话在loginType中输入的在值，不会被清除现在每次切换的时候，输入框都会被重新渲染 v-showv-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 注意：v-show 不支持 &lt;template&gt; 元素，也不支持 v-else v-show 与 v-ifv-if是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当被销毁和重建v-if也是有惰性的，如果在初始渲染时候条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记04","slug":"vue日记04","date":"2019-07-02T12:27:29.000Z","updated":"2019-07-10T14:35:45.701Z","comments":true,"path":"2019/07/02/vue日记04/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记04/","excerpt":"","text":"vue日记04Class 与 Styleclass 对象语法给 v-bind:class 一个对象，以动态地切换 class：1234567891011121314&lt;style&gt; .active &#123; background:red; &#125; .text &#123; color:green; &#125;&lt;/style&gt;&lt;div :class=&quot;&#123;active:isActive,text: hasError&#125;&quot;&gt;&lt;/div&gt;data:&#123; isActive:true , hasError:true &#125;渲染结果：&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; class 数组语法把一个数组传给 v-bind:class，以应用一个 class 列表1234567891011121314&lt;style&gt; .active&#123; background:yellow; &#125; .error&#123; color:red; &#125;&lt;/style&gt;&lt;div :class=&quot;[activeCalss,errorClass]&quot;&gt;&lt;/div&gt;data:&#123; activeCalss:&apos;active&apos;, errorClass:&apos;error&apos;&#125;渲染结果：&lt;div class=&quot;active error&quot;&gt;&lt;/div&gt; 当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：1&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt; style 对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：123456&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize&#125;&quot;&gt;&lt;/div&gt;data:&#123; activeColor:&apos;red&apos;, fontSize:&apos;30px&apos;&#125;渲染结果：&lt;div style=&quot;color:red font-size= 30xp&quot;&gt;&lt;/div&gt; 或者直接绑定到一个样式对象通常更好，这样是的模板更清晰：1234567&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;data:&#123; styleObject:&#123; activeColor:&apos;red&apos;, fontSize:&apos;30px&apos; &#125;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。 style 数组语法v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记03","slug":"vue日记03","date":"2019-07-02T10:27:29.000Z","updated":"2019-07-10T15:18:29.922Z","comments":true,"path":"2019/07/02/vue日记03/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记03/","excerpt":"","text":"vue日记03计算属性 - methods - watchexample：123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125;&lt;div&gt; 对于任何复杂的逻辑，应使用计算属性12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reversedMessage1()&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reversedMessage2&#125;&#125;&lt;/p&gt;&lt;div&gt;var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&apos;hello&apos; &#125;, methods:&#123; reversedMessage1 ()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; computed:&#123; reversedMessage2()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 以上计算属性和methods中定义的方法都可以得到结果，区别是：计算属性是基于它们的响应式的依赖进行缓存的，只有在它们的响应式的依赖发生改变的时候它们才会去重新求值，也就是说data中message的值不发生改变，多次reversedMessage会立即返回之前的计算结果，而不会再次执行函数对于methods，只要发生重新渲染，那么methods中的函数就会被调用 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。以官网例子： 使用watch：123456789101112131415161718&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 使用computed：1234567891011121314&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; firstName:&apos;Foo&apos;, lastName:&apos;Bar&apos;, &#125; watch:&#123; fullName()&#123; return this.firstName + &apos;&apos; + this.lastName &#125; &#125;&#125;) 相比较还是computed更合适 计算属性默认只有getter,不过在需要时你也可以提供一个setter官网例子:123456789101112computed:&#123; fullName:&#123; get()&#123; //getter return this.firstName + &apos;&apos; + this.lastName &#125;, set(newValue)&#123; //setter let names = newValue.split(&apos;&apos;) this.firstName = names[0] this.lastName = names[names.length -1] &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记02","slug":"vue日记02","date":"2019-07-02T04:27:29.000Z","updated":"2019-07-10T15:18:34.586Z","comments":true,"path":"2019/07/02/vue日记02/","link":"","permalink":"http://www.hefang.site/2019/07/02/vue日记02/","excerpt":"","text":"vue日记02模板语法数据绑定最常见的形式就是使用mustache语法的文本差值:1&lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; JavaScript 表达式可以使用表达式进行简单的运算和三目运算等，Vue.js只支持单个表达式，不支持语句和流控制12&#123;&#123;1 + 1 * 1&#125;&#125;可以进行简单的运算 12&#123;&#123;1 &lt; 2 ? value :a&#125;&#125;可以使用三目运算符 12&#123;&#123;if( a &gt; 3)&#123;&#125;&#125;&#125;文本插值的形式，其中不能书写表达式,支持单个表达式 指令和事件指令是Vue模板中最常见的一项功能，它带有前缀v-,能快速帮助我们完成DOM操作循环渲染，显示和隐藏v-text 解析文本和作用一样‘v-html 解析htmlv-on 用来绑定事件监听器v-bind 动态更新html上的元素属性 修饰符.prevent 提交事件不再重载页面.stop 阻止单击事件冒泡.self 只当事件在该元素本身（不包括子元素）触发时触发回调.capture 添加事件监听器使用事件捕获模式.once 事件只能点击一次","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.hefang.site/categories/Vue/"}],"tags":[]},{"title":"vue日记01","slug":"vue日记01","date":"2019-07-01T12:27:29.000Z","updated":"2019-07-09T15:37:34.121Z","comments":true,"path":"2019/07/01/vue日记01/","link":"","permalink":"http://www.hefang.site/2019/07/01/vue日记01/","excerpt":"","text":"vue日记01条件渲染v-if控制切换一个元素是否显123456&lt;div v-if=isActive&gt;&lt;/div&gt;&lt;div v-else&gt;&lt;/div&gt;data:&#123; isActive:true&#125; 数据与方法当一个Vue实例被创建的时候，它的data里面所有的数据都会被加入到Vue相应系统中，如果data里面的值发生改变，视图也会产生相应的改变，将值更新为最新的12345var data = &#123;a:1&#125;var vm = new Vue(&#123; data:data&#125;)data.a = vm.a 设置a的值也会影响到原始数据（data），反之也是一样12vm.a = 2data.a = 2 所以当数据发生改变的时候，视图会进行重新渲染，只有在实例在被创建时data中存在的属性才是响应式的，比如说添加一个新的属性1data.b = 10 那么b的值的更新并不会触发任何视图的更新 特殊：Object.freeze() 它会阻止修改现有的属性，响应式无法在追踪变化123456789101112131415var fn = &#123; a:1&#125;Objectfreezz(fn)var app = new Vue(&#123; el:&quot;#app&quot;, data:fn &#125;&#125;)&lt;div id=&quot;app&quot;&gt; &lt;button @click=noChange&gt;&lt;/button&gt;&lt;/div&gt; 当点击按钮时候fn不会更新 watch1234567891011var value = &#123;a:1&#125;var app = new Vue(&#123; el:&quot;#app&quot;, data:value&#125;)app.$data === valueapp.$el === document.getElementById(&apos;app&apos;)app.$watch(&apos;a&apos;,function(newValue,oldvalue)&#123; // 这个回调将在 `vm.a` 改变后调用 &#125;) 生命周期钩子每一个Vue实例被创建的时候都要经过一系列初始化的过程，需要设置数据监听，编译模板，将实例挂在到DOM上且在数据改变的时候更新DOM，同时在这一过程中也会运行一些生命周期钩子的函数生命周期钩子的this上下文指向调用它的Vue实例","categories":[{"name":"vue","slug":"vue","permalink":"http://www.hefang.site/categories/vue/"}],"tags":[]},{"title":"js基本知识","slug":"js基本知识","date":"2019-06-23T14:27:29.000Z","updated":"2019-06-24T15:15:59.603Z","comments":true,"path":"2019/06/23/js基本知识/","link":"","permalink":"http://www.hefang.site/2019/06/23/js基本知识/","excerpt":"","text":"JavaScript 定义了几种数据类型? 哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么?1.JavaScript 定义了几种数据类型? 一共有6种，分别是： 数值(number)：整数和小数；字符串(string)：字符组成的文本；布尔值(boolean)：true（真），flase（假）；underfined：表示未定义，不存在。null：空值，但不代表不存值。对象（object）：各种值的组合集合； 2.哪些是原始类型?数值，字符串，布尔值，称为原始类型的值，也叫基本类型。即它们是最基本的数据类型，不能再细分。 3.哪些是复杂类型？对象就是复杂类型，也叫做引用类型，因为对象往往是多个原始类型的值的合成，可以看作是一个存放各种值得容器。 对象细分为: 侠义的对象。 数组（Array） 函数（function） 正则表达式 ps：underfined和null一般看作是两个特殊的值。 4.原始类型和复杂类型有什么区别？ 基本类型一般存放于栈内存，是一个单一的值。 引用类型存放于堆内存中。用一个变量，放在栈内存中，指明它的地址。是一个包含各种值得容器。 typeof和instanceof的作用和区别? typeof： 一般用来检测基本类型是什么类型，例如：123``` 得到的值就是```number```。可是如果检测引用类型的话就会返回```object```，不能明确区分到底是```&#123;&#125;``` 还是数组```[]```。(检测函数的时候会返回```funtion```)123456789ps：```typeof null``` 是```object```，```typeof underfined``` 得到的是```underfined```。- instanceof：用来检测对象到底是数组```[]```，还是```&#123;&#125;```。### 如何判断一个变量是否是数字、字符串、布尔、函数?&gt; ```typeof 123 //number 'hello'link1```typeof true //boolean f()&#123;&#125; typeof flink12345678### NaN是什么? 有什么特别之处?- NaN本身是一个Number，基本类型。（我是一个数据类型，但是我不是一个有效的数据！！！！！！！！！！！！）- NaN含义是Not a Number，表示非数字，NaN和任何值都不相等，包括自己。### 如何把非数值转化为数值?- parseInt() （如果遇到小数点，会把小数向下约等于，转换为整数。 ）```parseInt(&apos;123&apos;) // 123 // 3```12- parseFloat() （如果遇到小数，会保留小数，转换为数据类型。）``` parseFloat(&apos;3.4&apos;) // 3.4 ==与===有什么区别? ==： 是近似等于。 == 在比较的时候可以转自动换数据类型 ===： 是绝对等于。 === 严格比较，不会进行自动转换，要求进行比较的操作数必须类型一致，不一致时返回flase。 break与continue有什么区别？ break是立即跳出循环。 continue 是跳出本次循环。执行下次循环。 void 0 和 undefined在使用场景上有什么区别? void 会执行后面的表达式并返回 undefined，是一个纯正的undefined； underfined可以在局部作用域被赋值，复写。","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"string Array方法总结","slug":"string Array方法总结","date":"2019-06-23T12:27:29.000Z","updated":"2019-06-23T15:29:37.813Z","comments":true,"path":"2019/06/23/string Array方法总结/","link":"","permalink":"http://www.hefang.site/2019/06/23/string Array方法总结/","excerpt":"","text":".toUpperCase() 变成大写123var a=&quot;string&quot;var b=a.toUpperCase()console.log(b)//&quot;STRING&quot; .toLowerCase() 变成小写123var a=&quot;STRING&quot;var b=a.toLowerCase()console.log(b)//&quot;string&quot; .split() 以括号里面的内容为分界点，让字符串变为数组1234567891011121314例子1：var a=&quot;string-ing&quot;var b=a.split(&quot;-&quot;)console.log(b)//[&quot;string&quot;,&quot;ing&quot;]例子2：var a=&quot;string&quot;var b=a.split()//可以不写东西console.log(b)//[&quot;string&quot;]例子3var a=&quot;string&quot;var b=a.split(&quot;&quot;)console.log(b)//[&quot;s&quot;, &quot;t&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;]; .join() 让数组以括号里面的内容合并成一个字符串12345678var a=[1,2,3,4,5,6]var b=a.join(&quot;&quot;)console.log(b)//123456例子2：var a=[1,2,3,4,5,6]var b=a.join()console.log(b)//1,2,3,4,5,6 substr() 获取字符串指定的部分123456var a=&quot;string&quot;var b=a.substr(1,2)//获取了从1开始的后面2个字符串，包括1////如果省略第二个参数，会自动获取到最后console.log(b)//trconsole.log(a)//&quot;string&quot; 这个方法不会对原字符串做出任何修改 substring() 获取字符串指定的部分123456var a=&quot;string&quot;var b=a.substring(1,2)//获取了从1开始的后面2个字符串，这个不包括1//如果省略第二个参数，会自动获取到最后console.log(b)//jconsole.log(a)//&quot;string&quot; 这个方法不会对原字符串做出任何修改 reverse()把数组翻转123var a=[1,2,3,4,5];var b=a.reverse()console.log(b)//[5,4,3,2,1] toString//把数组变成字符串，就用逗号隔开123var a=[1,2,3,4,5,6]var b=a.toString()console.log(b)//1,2,3,4,5,6 splice() 切取数组的值（会改变原来的数组）1234var a=[1,2,3,4,5,6]var b=a.splice(0,1,2)//从0开始索引，窃取1位数，会包括0，然后把窃取的位置添加2console.log(b)//[1]console.log(a)//[2,2,3,4,5,6] slice()窃取数组的元素，不会改变原数组。1234var a=[1,2,3,4,5,6]var b=a.slice(0,3)包括第0位，从第0位开始窃取后面的三个元素。不会改变原数组console.log(b)//[1,2,3]console.log(a)//[1,2,3,4,5,6] push() / pop() 从数组后面添加元素 / 从数组后面删除元素 （都会改变原数组）12345var a=[1,2,3,4,5,6]a.push(7)console.log(a)//[1,2,3,4,5,6,7]a.pop()console.log(a)//[1,2,3,4,5,6] unshift() / shift() 从数组前端添加元素 / 从数组前端删除元素 （都会改变原数组）12345var a=[1,2,3,4,5,6]a.unshift(7)console.log(a)//[7,1,2,3,4,5,6]a.shift() console.log(a)//[1,2,3,4,5,6]","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"正则表达式汇总","slug":"正则表达式汇总","date":"2019-06-22T10:27:29.000Z","updated":"2019-06-22T14:30:14.944Z","comments":true,"path":"2019/06/22/正则表达式汇总/","link":"","permalink":"http://www.hefang.site/2019/06/22/正则表达式汇总/","excerpt":"","text":"1.正则表达式一般命名为regex2.JS正则表达式常用的方法12345RegExpObject.test(string) //方法用于检测一个字符串是否匹配某个模式.stringObject.match(regexp) //方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配RegExpObject.exec(string) //方法用于检索字符串中的正则表达式的匹配。 方法举例12345let regex = /\\d/let str = 123123let str2 = &apos;cwh&apos;regex.test(str) //trueregex.test(str2)//false 123var regex = /(\\d&#123;4&#125;)\\S(\\d+)[-](\\d+)/var str = &apos;2017-1-12&apos;str.match(regex) // [&apos;2017&apos;,&apos;2017&apos;,&apos;1&apos;,&apos;12&apos;] 123var regex = /\\d/var str = 123123123regex.exec(str) // [1],[2],[3],[1]...[null],[1].... 3.常用限定符号 代码语法 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或者1次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 4.常用元字符 代码语法 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 5.常用的反义代码 代码语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这个几个字母以外的任意字符 6.编辑器如何用正则 代码解析 匹配div 匹配任意的空白符 匹配class 保留div 保留class 直接替换掉空格 注意： 有时候替换符是/1 又或者是 $","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"css常见样式","slug":"解析白屏和FOUC","date":"2019-06-11T14:11:29.000Z","updated":"2019-06-11T15:36:14.111Z","comments":true,"path":"2019/06/11/解析白屏和FOUC/","link":"","permalink":"http://www.hefang.site/2019/06/11/解析白屏和FOUC/","excerpt":"","text":"解析白屏和FOUC白屏：1.css导致 如果把样式放在底部，对于IE浏览器，某些场景下（打开新的窗口，刷新页面）时会出现白屏，而不是逐步展现内容； 如果使用@import标签，即使CSS放在头部，用link引入，也有可能出现白屏。 白屏产生的原因和浏览器的渲染机制有关，在painting之前的步骤上有时间的延迟，主要是CSS加载的延迟。 2.js导致： 把JS放在顶部可能会导致白屏。 对于图片和CSS，在加载时会并发加载（如同个域名下同时加载两个文件），但在加载JS时，会禁用并发（脚本会阻塞后面内容的呈现几后面组件的加载），所以把JS放在页面顶部会导致白屏现象。 FOUC： FOUC（Flash Of Unstyled Content，文档样式闪烁）, 产生的原因：如果把css放在底部，对于IE浏览器，对于某些场景，就会出现FOUC现象，对于firfox会一直表现FOUC， 解决办法：把link放在头部。 把@import换成link引入","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"深拷贝函数","slug":"深拷贝函数","date":"2019-05-29T12:27:29.000Z","updated":"2019-05-29T13:44:59.187Z","comments":true,"path":"2019/05/29/深拷贝函数/","link":"","permalink":"http://www.hefang.site/2019/05/29/深拷贝函数/","excerpt":"","text":"第一种:function copy(obj){ var newObject={}; for (var key in obj) { if(typeof obj[key] === &apos;number&apos;||typeof obj[key] === &apos;boolean&apos;||typeof obj[key] === &apos;string&apos;||obj[key] ===undefined||obj[key] === null){ newObject[key]=obj[key]; } else{ newObject[key]=copy(obj[key]) } } return newObject; } 第二种:var cloneObj = JSON.parse(JSON.stringify(obj));","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"css常见样式2","slug":"css常见样式2","date":"2019-05-26T10:27:29.000Z","updated":"2019-05-26T11:02:37.241Z","comments":true,"path":"2019/05/26/css常见样式2/","link":"","permalink":"http://www.hefang.site/2019/05/26/css常见样式2/","excerpt":"","text":"1.text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中 作用在行内元素上，实现行元素居中。 2. IE盒子模型和W3C盒子模型有什么区别？ IE 的盒子模型content 中包含了border和padding W3C的盒子模型content是不包括border和padding的 3、 { box-sizing: border-box;}的作用是什么？ 转换为IE的盒子模型，就是内容包括了border和padding{ box-sizing: content-box;}的作用是什么？ 默认值了，就是普通的W3C盒子模型。 4.line-height: 2和line-height: 200%有什么区别? line-height: 200%：当前字体尺寸的百分之两百设置行间距。 line-height: 2： 数字会与当前的字体尺寸相乘来设置行间距。 5.inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? inline-block：对象为内联对象，但是对象的内容可以作为块对象操作。(简单认为，可以设置大小的内联元素) 如何去除缝隙： 1.你可以把标签与标签之间的空格全部删除，但是这样不美观。2.在父元素设置，font-size：0；然后在你想设置的元素上再重新设置font-size：；(简单点说就是将空白字符的高度都设置为0)；3.高度不一样的inline-block元素如何顶端对齐：vertical-align: top; 6.CSS sprite 是什么? 简称雪碧图 你上去淘宝看看那些一个一个的icon就是雪碧图 优点：减少网页的http请求，从而大大的提高页面的性能 7.让一个元素”看不见”有几种方式？有什么区别? 方法 区别 opacity：0； 改变了透明度，让你看不见了。 还存在 display: none; 会让选中的元素直接删除； visibility：hidden； 类似于 opacity 还存在 background：rbga(0，0，0，0.2) 也是改变背景颜色，和透明度 还存在","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"css常见样式","slug":"css常见样式","date":"2019-05-24T14:10:29.000Z","updated":"2019-05-24T14:44:36.941Z","comments":true,"path":"2019/05/24/css常见样式/","link":"","permalink":"http://www.hefang.site/2019/05/24/css常见样式/","excerpt":"","text":"1.块级元素和行内元素分别有哪些？块级元素：div，h1~h6，table，form，header， footer，nav，ul，li，ol，dl。。。。。行内元素：a，input，span，i，img，strong， select。。。。。 2.动手测试并列出4条以上的特性区别。 块级元素 行内元素 没有设置宽度的情况下，默认占据一整行 内容有多宽，我就有多宽 可以随便设置宽高 不可以 随便设置padding，margin padding和margin只可以设置左右 可以包裹块级元素，行内元素 我只能包裹文本，和行内元素 3.什么是 CSS 继承? 哪些属性能继承，哪些不能？CSS继承，就是子元素继承了父元素的属性。 能继承 不能继承 letter-spacing height word-spacing min-height white-space max-height line-height width color min-width font max-width font-style float font-family position text-align overflow text-indent vertical-align font-weight clear 等等等等 等等等等 4.如何让块级元素水平居中？如何让行内元素水平居中?块级元素水平居中：margin：0 auto；行内元素水平居中：text-align：center； 5.单行文本溢出加…….如何实现？E{white-space:nowrap;overflow:hidden;text-overflow;} 6.px, em, rem 有什么区别 px：固定尺寸； em： 相对于当前对象内文本的字体尺寸 rem： 相对于HTML的相对大小 7.解释下面代码的作用?为什么要加引号? 字体里\\5b8b\\4f53代表什么?body{ font: 12px/1.5 tahoma,arial,’Hiragino Sans GB’,’\\5b8b\\4f53’,sans-serif;} 1.设置body字体大小为12px，行高是字体1.5倍的像素值，后面则是第一到第五字体，用逗号隔开，如果第一个你电脑没有，则运行第二个。2.加引号是因为，字体间有空格，这样会识别为不同的两个单词，所以加空格。3.字体那些代码代表“宋体” ps:在浏览器console里输入escape（”你想要的字体编码”），就能出现像想要的代码记住将%u改成/。","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"flex","slug":"flex","date":"2019-05-22T10:27:29.000Z","updated":"2019-05-22T12:23:42.002Z","comments":true,"path":"2019/05/22/flex/","link":"","permalink":"http://www.hefang.site/2019/05/22/flex/","excerpt":"","text":"flex在学习flex只是之前，平时的demo中使用到的传统布局主要有以下几种： 1、normal flow 文档流、正常流2、float + clear 清除浮动3、position relative + absolute 相对 + 绝对定位4、display inline-block 横向布局5、负 margin 扩大宽度、产生位移 这些传统的布局方式虽然可以满足我们的很多需求，但是也并不方便，比如实现垂直居中。而现在我们就要开始接触flex布局这种新的布局方式了。flex也可称为“弹性布局”，flex布局有以下几个特点： 1、块级布局侧重垂直方向，行内布局侧重水平方向。flex布局与方向无关2、flex布局可以实现空间自动分配，自动对齐3、flex布局适用于简单的线性布局，复杂的布局则可以使用grid布局 接下来就将对flex布局的几个重要知识点进行归纳。 flex布局的基本概念采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）。 flex container 的属性flex container（flex容器）有如下六个属性：flex-direction,flex-wrap,flex-flow,jstify-content,align-items,align-content flex-direction 方向-属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。该属性主要有以下值：row,row-reverse,column,column-reverse, 以flex-direction:row-reverse为例： https://jsbin.com/kugepiposa/edit?html,css,output flex-wrap 指定 flex 元素单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。该属性主要有以下值： wrap,nowrap,wrap-reverse, 以flex-wrap:wrap;为例： https://jsbin.com/pugumitoli/1/edit?html,css,output flex-flow 上面两个属性的缩写默认值为row nowrap，可以以如下方法设定该属性： .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } justify-content 主轴方向的对齐方式space-between,space-around,flex-start,flex-end,center以justify-content:space-between为例： https://jsbin.com/jowuvubiju/1/edit?html,css,output align-items 侧轴方向的对齐方式stretch,flex-start,flex-end,center,baseline 以align-items:center为例： https://jsbin.com/pebevizeri/1/edit?html,css,output align-content 多行多列的对齐方式space-between，space-around，flex-start，flex-end，stretch， flex item 的属性flex item（子元素）有如下六个属性： order flex-grow flex-shrink flex-basis flex align-self flex-grow该属性默认值为0。如果所有子元素的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个子元素的flex-grow属性为2，其他子元素都为1，则前者占据的剩余空间将比其他项多一倍。 例子： https://jsbin.com/vayolutake/1/edit?html,css,output flex-shink 空间不足时的收缩比例该属性默认值为1。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 例子： https://jsbin.com/deriqobuwu/1/edit?html,css,output、 flex-basis 子元素的默认宽度flex-basis属性定义了在分配多余空间之前，子元素占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来宽度。 例子： https://jsbin.com/vivuserebe/1/edit?html,css,output 使用flex布局的几个技巧flex 布局可以简便、完整、响应式地实现各种页面布局。下面就简要地记录几个flex布局的技巧 实现手机布局如果内容被修剪，需要浏览器显示滚动条，以便查看剩余内容，可以使用 over-flow:auto;实现手机上中下布局： .content{ height:100vh; display:flex; flex-direction:column; } 实现电脑左中右布局 .content&gt;aside{width:120px;} .content&gt;main{height:400px;flex:1} .content&gt;nav{width:100px;} 完美居中 .parent{ display:flex; justify-content:center; align-items:center; }","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"常见排序算法","slug":"常见排序算法","date":"2019-05-21T06:51:00.000Z","updated":"2019-05-22T04:09:31.898Z","comments":true,"path":"2019/05/21/常见排序算法/","link":"","permalink":"http://www.hefang.site/2019/05/21/常见排序算法/","excerpt":"","text":"常见排序算法 - 冒泡排序 (Bubble Sort)冒泡排序算法的流程如下：1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3、针对所有的元素重复以上的步骤，除了最后一个。4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实例分析：以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：第一次外循环 ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置 ( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置 ( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置 ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列） ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变 ( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置 ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) JavaScript 语言实现function bubbleSort(array) { var length = array.length, i, j, temp; for (i = length - 1; 0 &lt; i; i--) { for (j = 0; j &lt; i; j++) { if (array[j] &gt; array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } return array; } 流程图预览地址 常见排序算法 - 选择排序 (Selection Sort)算法原理选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 实例分析：以数组 arr = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）： min ↓ 8 5 2 6 9 3 1 4 0 7 ↑ ↑ └───────────────────────────────┘ 交换后： 0 5 2 6 9 3 1 4 8 7 在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换： min ↓ 0 5 2 6 9 3 1 4 8 7 ↑ ↑ └───────────────────┘ 交换后： 0 1 2 6 9 3 5 4 8 7 在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）： min ↓ 0 1 2 6 9 3 5 4 8 7 ↑ 重复上述过程，直到最后一个元素就完成了排序。 min ↓ 0 1 2 6 9 3 5 4 8 7 ↑ ↑ └───────┘ min ↓ 0 1 2 3 9 6 5 4 8 7 ↑ ↑ └───────────┘ min ↓ 0 1 2 3 4 6 5 9 8 7 ↑ ↑ └───┘ min ↓ 0 1 2 3 4 5 6 9 8 7 ↑ min ↓ 0 1 2 3 4 5 6 9 8 7 ↑ ↑ └───────┘ min ↓ 0 1 2 3 4 5 6 7 8 9 ↑ min ↓ 0 1 2 3 4 5 6 7 8 9 ↑ JavaScript 语言实现function selectionSort(array) { var length = array.length, i, j, minIndex, minValue, temp; for (i = 0; i &lt; length - 1; i++) { minIndex = i; minValue = array[minIndex]; for (j = i + 1; j &lt; length; j++) { if (array[j] &lt; minValue) { minIndex = j; minValue = array[minIndex]; } } // 交换位置 temp = array[i]; array[i] = minValue; array[minIndex] = temp; } return array } 流程图预览地址","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"grid","slug":"grid","date":"2019-05-21T03:27:29.000Z","updated":"2019-05-23T04:24:38.699Z","comments":true,"path":"2019/05/21/grid/","link":"","permalink":"http://www.hefang.site/2019/05/21/grid/","excerpt":"","text":"grid网格布局可以将应用程序分割成不同的空间，定义它们的大小、位置和层级。 简单来说，网格布局就像表格一样可以让元素按列和行对齐排列，不同的是，网格布局没有内容结构，比如一个网格布局的子元素可以定位自己的位置，可以是实现类似定位的效果。 兼容性caniuse可以看到几大浏览器都已经支持了Grid布局 grid vs flex我们知道flex和grid都是css3新的布局方式，如果浏览器都支持两种布局，你会选择那种呢？当我们了解两者以后就能做出正确的选择了。 flex布局是一维布局，grid布局是二维布局。 Grid属性分为两类，一类作用于grid容器，一类作用于grid子项目上。属性繁多，按需选用。 作用于grid容器 grid-template-columns grid-template-rows grid-template-areas grid-template grid-column-gap grid-row-gap grid-gap justify-items align-items place-items justify-content align-content place-content grid-auto-columns grid-auto-rows grid-auto-flow grid作用于grid子项目作用于grid子项目 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self place-self 举例几种布局：1、左右固定，中间自适应预览地址 2、九宫格预览地址 大多数网站布局预览地址 总结来说： CSS Grid 是一个二维的布局系统CSS Grid 相比传统布局在页面整体划分布局上更加出色CSS Grid 并不是只能单独使用，依然可以搭配Flexbox以及传统定位布局一起使用","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"原型与原型链","slug":"原型与原型链","date":"2018-12-11T02:44:29.000Z","updated":"2019-05-22T04:09:13.949Z","comments":true,"path":"2018/12/11/原型与原型链/","link":"","permalink":"http://www.hefang.site/2018/12/11/原型与原型链/","excerpt":"","text":"例子1function Person(name){ this.name = name; this.age = age; } Person.prototype.sayName = function(){ console.log(this.name); } var p1 = new Person(&apos;a&apos;); var p2 = new Person(&apos;b&apos;); p1.sayName(); p2.sayName(); 1.new 一个函数本质上做了什么？ 1)创建了一个空的对象 2)空对象的proto指向了类Modal()的prototype 3)在执行函数的过程中，给this赋值，函数里的this代表了空对象，返回出去 4)将this赋值给modal2.通过函数定义了一个类Person，它自动获取了属性prototype，每个类的实例也就是p1、p2内部都会有一个proto的属性，如下图: 例子2当前的p1实例，查找toString()的方法先从p1的属性里找，没有找到,再从 p1.proto 中找，没有找到,再从 p1.proto.proto 中找，找到后返回 例子3function People(){} var p = new People() p.__proto__ === People.prototype People.__proto__ === Function.prototype People.prototype.__proto__ === Object.prototype （1）People函数创建了对象 p，所以People.prototype === p.proto；（2）Object函数创建了People.prototype对象，所以Object.prototype === People.prototype.proto；（3）People 作为对象的角色被函数Function创建，所以 Function.prototype === People.proto; 例子4（1）任何函数都是 Function 创建，所以Function 创建了 Function，所以 Function.prototype === Function.proto；（2）Object 也是函数。所以Function创建了Object，所以 Function.prototype === Object.proto ；（3）Function.prototype 是普通对象，普通对象是由Object创建的，所以 Function.prototype.proto === Object.prototype 例子5Object instanceof Function Function instanceof Object Function instanceof Function Object instanceof Object instanceof的作用是判断一个对象是不是一个函数的实例。比如obj instanceof fn,实际上是判断fn的prototype是不是在obj的原型链上。比如: obj.__proto__ === fn.prototype obj.__proto__.__proto__ === fn.prototype obj.__proto__..._proto__ === fn.prototype 只要一个成立即可。1.对于Function instanceof Function,因为 Function.proto === Function.prototype所以为true。 2.对于Object instanceof Object,因为 Object.proto.proto === Function.prototype.proto === Object.prototype,所以为true 3.对于Function instanceof Object,因为 Function.proto.proto === Function.prototype.proto === Object.prototype,所以为true 4.对于Object instanceof Function,因为 Object.proto === Function.prototype所以为true","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"动画队列","slug":"动画队列","date":"2018-10-26T10:27:29.000Z","updated":"2019-05-22T04:09:09.298Z","comments":true,"path":"2018/10/26/动画队列/","link":"","permalink":"http://www.hefang.site/2018/10/26/动画队列/","excerpt":"","text":"动画队列jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。 .stop( [clearQueue ] [, jumpToEnd ] )（添加版本1.2）clearQueue类型: Boolean一个布尔值，指示是否取消以列队动画。默认 false.jumpToEnd类型: Boolean一个布尔值指示是否当前动画立即完成。默认false. .stop( [queue ] [, clearQueue ] [, jumpToEnd ] )（添加版本1.7）queue类型: String停止动画队列的名称。clearQueue类型: Boolean一个布尔值，指示是否取消以列队动画。默认 false.jumpToEnd类型: Boolean一个布尔值指示是否当前动画立即完成。默认false.jQuery中有stop这个方法可以停止当前执行的动画，并且它有两个布尔参数，默认值都为false。 clearQueue(default: false) jumpToEnd(default: false) 第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以，我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后面的队列丢弃了，这就会出现意料之外的结果。 ###我们可以看到如下整理结果: 方法 参数 说明 stop() 清空队列，当前执行动作立即停止。后续动作会不再执行。 等同于：stop(false,false) stop(true) [clearQueue] 清空队列，当前执行动作立即停止。后续动作会不再执行 stop(true,true) [clearQueue],[gotoEnd] 清空队列，当前执行动作立即完成。后续动作会不再执行 stop(true,false) [clearQueue],[gotoEnd] 清空队列，当前执行动作立即停止。后续动作会不再执行 stop(false) [clearQueue] 不清空队列，当前执行动作立即停止。后续动作会立即执行 stop(false,true) [clearQueue],[gotoEnd] 不清空队列，当前执行动作立即完成。后续动作会立即执行 stop(false,false) [clearQueue],[gotoEnd] 不清空队列，当前执行动作立即停止。后续动作会立即执行","categories":[{"name":"jquery","slug":"jquery","permalink":"http://www.hefang.site/categories/jquery/"}],"tags":[]},{"title":"CORS","slug":"跨域(CORS)","date":"2018-10-02T08:27:29.000Z","updated":"2019-05-22T04:09:43.265Z","comments":true,"path":"2018/10/02/跨域(CORS)/","link":"","permalink":"http://www.hefang.site/2018/10/02/跨域(CORS)/","excerpt":"","text":"cors为什么要跨域？跨域问题是浏览器同源策略限制，当前域名的js只能读取同域下的窗口属性。一个网站的网址组成包括协议名，子域名，主域名，端口号。比如 https://www.github.com/80，其中https是协议名,www.github.com是子域名，github.com是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在http://localhost:80/ 页面请求http://127.0.0.1:80 也会有跨域问题（因为域名不一样嘛~） 跨域的实现的几种方式1、Jsonp最常见的一种跨域方式，其背后的原理就是利用script标签不受同源策略的限制，在页面中动态插入script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理的函数名名告诉后端，后端在响应请求时会将函数回调返回，并且将数据以参数的形式传递回去代码部分： &lt;script&gt; function showData(ret){ console.log(ret); } &lt;/script&gt; 2、CORS当使用XMLHttpRequest发送请求是，如果浏览器发现了违反了同源策略就会自动加上一个请求头：origin，后端在接受请求的时候确定响应后会在Response Headers中加入一个熟悉：Access-Control-Allow-Origin，value就是发起请求的源地址 http://127.0.0.1:8080，浏览器得到响应会继续判断Access-Control—Allow—Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理 var http = require(&apos;http&apos;) var fs = require(&apos;fs&apos;) var path = require(&apos;path&apos;) var url = require(&apos;url&apos;) http.createServer(function(req,res){ var pathObj = url.parse(req.url,true) switch(pathObj.pathname){ case &apos;/getWeather&apos;: var weather =[ &quot;beijing&quot;:&quot;sunny&quot;, &quot;shanghai&quot;:&quot;cloudy&quot; ] res.setHeader(&apos;Access-Control-Allow-Origin&apos;,http://localhost:8080) res.end(JSON.stringify(weather)) break; default: fs.readFile(parse.join(__dirname,pathObj.pathname),function(e,data){ if(e){ res.writeHead(404, &apos;not found&apos;) res.end(&apos;&lt;h1&gt;404 not found&lt;/h1&gt;&apos;) }else{ res.end(data) } }) } }).listen(8080) $(&apos;.change&apos;).addEventListener(&apos;click&apos;, function () { var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, &apos;http://localhost:8080/getWeather&apos;, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { appendHtml(JSON.parse(xhr.responseText)) } }; }); 2、window.postMessage(message,targetOrigin)方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。这种方法不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据","categories":[{"name":"http","slug":"http","permalink":"http://www.hefang.site/categories/http/"}],"tags":[]},{"title":"cookie&session&localStorage","slug":"cookie&session&localStorage","date":"2018-09-15T12:27:29.000Z","updated":"2019-05-26T10:58:34.360Z","comments":true,"path":"2018/09/15/cookie&session&localStorage/","link":"","permalink":"http://www.hefang.site/2018/09/15/cookie&session&localStorage/","excerpt":"","text":"cookie&amp;session&amp;localStorage一、cookiecookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。在控制台用 「document.cookie」查看你当前正在浏览的网站的cookie。cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用 HTTP 协议规定的 set-cookie 来让浏览器种下cookie，这是最常见的做法。（打开一个网站，清除全部cookie，然后刷新页面，在network的Response headers试试找一找set-cookie吧）每次网络请求 Request headers 中都会带上cookie。所以如果 cookie 太多太大对传输效率会有影响。一般浏览器存储cookie 最大容量为4k，所以大量数据不要存到cookie。设置cookie时的参数：path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。expires 和 maxAge：告诉浏览器 cookie 时候过期，maxAge 是 cookie 多久后过期的相对时间。不设置这两个选项时会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。[cookie 参数][简述 Cookie 是什么] 二、session当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个session用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。创建session后，会把关联的session_id 通过setCookie 添加到http响应头部中。浏览器在加载页面时发现响应头部有 set-cookie字段，就把这个cookie 种到浏览器指定域名下。当下次刷新页面时，发送的请求会带上这条cookie， 服务端在接收到后根据这个session_id来识别用户。cookie 是存储在浏览器里的一小段「数据」，而session是一种让服务器能识别某个用户的「机制」，session 在实现的过程中需要使用cookie。当然有时候说到 session 也指服务器里创建的那个和用户身份关联的对象。 三、localStoragelocalStorage HTML5本地存储web storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。不参与网络传输。一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"HTMLCollection 和 NodeList","slug":"HTMLCollection 和 NodeList","date":"2018-09-04T10:27:29.000Z","updated":"2019-05-22T04:11:15.493Z","comments":true,"path":"2018/09/04/HTMLCollection 和 NodeList/","link":"","permalink":"http://www.hefang.site/2018/09/04/HTMLCollection 和 NodeList/","excerpt":"","text":"HTMLCollection 和 NodeList节点都是单个对象，有时会需要一种数据结构，能够容纳多个节点。DOM提供两种集合对象，用于实现这种节点的集合：NodeList和HTMLCollection。 NodeList 对象代表一个有顺序的节点列表，HTMLCollection 是一个接口，表示 HTML 元素的集合，它提供了可以遍历列表的方法和属性 以下方法获取的为HTMLCollection对象 document.images //所有img元素 document.links //所有带href属性的a元素和area元素 document.forms //所有form元素 document.scripts //所有script元素 document.body.children document.getElementsByClassName(&quot;class1&quot;) 以下方法获取的为NodeList对象 document.getElementsByName(&quot;name1&quot;) document.getElementsByTagName(&quot;a&quot;) document.querySelectorAll(&quot;a&quot;) document.body.childNodes 如何查看？ document.body.childNodes.constructor HTMLCollection与NodeList基本相似 相同点： 都是类数组对象，节点的变化都会实时反映在集合中 不同点： 少部分方法不一样，比如 NodeList 有 forEach 方法，而 HTMLCollection 没有","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"随机生成ip、字符串、color","slug":"随机生成IP、字符串、颜色等","date":"2018-09-01T12:44:29.000Z","updated":"2019-05-22T04:09:52.683Z","comments":true,"path":"2018/09/01/随机生成IP、字符串、颜色等/","link":"","permalink":"http://www.hefang.site/2018/09/01/随机生成IP、字符串、颜色等/","excerpt":"","text":"随机生成ip、字符串、color//随机生成32位字符串 function getRandomStr(len) { var a = &apos;&apos; var b =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot; for (i = 0 ; i &lt;len; i++){ var c = Math.floor(Math.random()*b.length) a += b[c] } return a } var a = getRandomStr(32) console.log(a) //随机生成一个IP地址 function getRandIP(){ var ip=[] for (i= 0 ; i&lt;4; i++){ ip[i]= Math.floor(Math.random()*256) } return ip.join(&apos;.&apos;) } var ip = getRandIP() console.log(ip) //生成一个随机颜色字符串 function getRandColor(){ var color = &apos;#&apos; var dict =&apos;0123456abcdef&apos; for(i = 0; i &lt; 6; i++){ var index =Math.floor(Math.random()*dict.length) color += dict[index] } return color } var color = getRandColor() console.log(color) //min到max之间的 随机整数 function sum(min,max){ var sum =Math.floor(Math.random()*(max-min))+min return sum } console.log(sum(1,100))","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"实现一个flatten函数","slug":"实现一个flatten函数","date":"2018-09-01T04:44:29.000Z","updated":"2019-05-22T04:09:22.563Z","comments":true,"path":"2018/09/01/实现一个flatten函数/","link":"","permalink":"http://www.hefang.site/2018/09/01/实现一个flatten函数/","excerpt":"","text":"实现一个flatten函数实现一个flatten函数，将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组，数组中元素仅基本类型的元素或数组，不存在循环引用的情况。 Ex: flatten([1, [2], [3, [[4]]]]) =&gt; [1, 2, 3, 4]; //方法1 var arr = ([1, [2], [3, [[4]]]]) function flatten(arr){ var newArr = [] function _flat(arr){ arr.forEach(val=&gt;{ if(Array.isArray(val)){ _flat(val) }else{ newArr.push(val) } }) } _flat(arr) return newArr } //方法2 var arr = ([1, [2], [3, [[4]]]]) function flatten2(arr){ return arr.reduce(function(initArr, currentArr){ return initArr.concat(Array.isArray(currentArr)?flatten2(currentArr):currentArr) }, []) } console.log(flatten2(arr)) //[1, 2, 3, 4]","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"JavaScript专题之数组扁平化","slug":"数组扁平化","date":"2018-08-31T02:44:29.000Z","updated":"2019-05-22T04:09:37.594Z","comments":true,"path":"2018/08/31/数组扁平化/","link":"","permalink":"http://www.hefang.site/2018/08/31/数组扁平化/","excerpt":"","text":"扁平化数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。 举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下： var arr = [1, [2, [3, 4]]]; console.log(flatten(arr)) // [1, 2, 3, 4] 知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了 递归我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法： // 方法 1 var arr = [1, [2, [3, 4]]]; function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) { if (Array.isArray(arr[i])) { result = result.concat(flatten(arr[i])) } else { result.push(arr[i]) } } return result; } console.log(flatten(arr)) toString如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为： [1, [2, [3, 4]]].toString() // “1,2,3,4”调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？ // 方法2 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.toString().split(&apos;,&apos;).map(function(item){ return +item }) } console.log(flatten(arr)) 然而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，这种方法就会产生错误的结果。 reduce既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码： // 方法3 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.reduce(function(prev, next){ return prev.concat(Array.isArray(next) ? flatten(next) : next) }, []) } console.log(flatten(arr)) …ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： var arr = [1, [2, [3, 4]]];console.log([].concat(…arr)); // [1, 2, [3, 4]]我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： // 方法4 var arr = [1, [2, [3, 4]]]; function flatten(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flatten(arr)) undercore那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~ 在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。 /** 数组扁平化 @param {Array} input 要处理的数组 @param {boolean} shallow 是否只扁平一层 @param {boolean} strict 是否严格处理元素，下面有解释 @param {Array} output 这是为了方便递归而传递的参数 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528*/ function flatten(input, shallow, strict, output) { // 递归使用的时候会用到output output = output || []; var idx = output.length; for (var i = 0, len = input.length; i &lt; len; i++) { var value = input[i]; // 如果是数组，就进行处理 if (Array.isArray(value)) { // 如果是只扁平一层，遍历该数组，依此填入 output if (shallow) { var j = 0, length = value.length; while (j &lt; length) output[idx++] = value[j++]; } // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output else { flatten(value, shallow, strict, output); idx = output.length; } } // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output else if (!strict){ output[idx++] = value; } } return output; } 解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子： var arr = [1, 2, [3, 4]];console.log(flatten(arr, true, true)); // [3, 4]那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果： shallow true + strict false ：正常扁平一层shallow false + strict false ：正常扁平所有层shallow true + strict true ：去掉非数组元素shallow false + strict true ： 返回一个[]我们看看 underscore 中哪些方法调用了 flatten 这个基本函数： _.flatten首先就是 _.flatten： _.flatten = function(array, shallow) { return flatten(array, shallow, false);};在正常的扁平中，我们并不需要去掉非数组元素。 _.union接下来是 _.union： 该函数传入多个数组，然后返回传入的数组的并集， 举个例子： _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);=&gt; [1, 2, 3, 101, 10]如果传入的参数并不是数组，就会将该参数跳过： _.union([1, 2, 3], [101, 2, 1, 10], 4, 5);=&gt; [1, 2, 3, 101, 10]为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。 // 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27) function unique(array) { return Array.from(new Set(array)); } _.union = function() { return unique(flatten(arguments, true, true)); } _.difference是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference： 语法为： _.difference(array, *others) 效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。 举个例子： _.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);=&gt; [1, 3]实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值： function difference(array, ...rest) { rest = flatten(rest, true, true); return array.filter(function(item){ return rest.indexOf(item) === -1; }) }","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"js作用域","slug":"js作用域相关介绍","date":"2018-08-27T15:27:29.000Z","updated":"2019-05-22T04:08:49.404Z","comments":true,"path":"2018/08/27/js作用域相关介绍/","link":"","permalink":"http://www.hefang.site/2018/08/27/js作用域相关介绍/","excerpt":"","text":"JavaScript的作用域是什么作用域，在维基百科上解释是：在电脑程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： (1）程序最外层定义的函数或者变量var a = “tsrot”;function hello(){ alert(a);} function sayHello(){ hello();} alert(a); //能访问到tsrothello(); //能访问到tsrotsayHello(); //能访问到hello函数，然后也能访问到tsrot（2）所有末定义直接赋值的变量（不推荐）function hello(){ a = “tsrot”; var b = “hello tsrot”;} alert(a); //能访问到tsrotalert(b); //error 不能访问（3）所有window对象的属性和方法一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。function hello(){ var a = “tsrot”; alert(a);} hello(); //函数内可访问到tsrotalert(a); //error not defined","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"浏览器的渲染机制","slug":"介绍浏览器的渲染机制","date":"2018-05-27T11:27:29.000Z","updated":"2019-05-22T04:29:48.977Z","comments":true,"path":"2018/05/27/介绍浏览器的渲染机制/","link":"","permalink":"http://www.hefang.site/2018/05/27/介绍浏览器的渲染机制/","excerpt":"","text":"浏览器的渲染机制首先当用户输入一个URL的时候，浏览器就会发送一个请求，请求URL对应的资源。然后浏览器的HTML解析器会将这个文件解析，并且构建成一棵DOM树。在构建DOM树的时候，遇到JS和CSS元素，HTML解析器就换将控制权转让给JS解析器或者是CSS解析器。JS解析器或者是CSS解析器解析完这个元素时候，HTML又继续解析下个元素，直到整棵DOM树构建完成。DOM树构建完之后，浏览器把DOM树中的一些不可视元素去掉，然后与CSSOM合成一棵render树。接着浏览器根据这棵render树，计算出各个节点(元素)在屏幕的位置。这个过程叫做layout，输出的是一棵layout树。最后浏览器根据这棵layout树，将页面渲染到屏幕上去。","categories":[{"name":"http","slug":"http","permalink":"http://www.hefang.site/categories/http/"}],"tags":[]},{"title":"cookie&session&localStorage","slug":"call&apply","date":"0201-06-15T12:21:46.000Z","updated":"2019-06-21T15:10:14.398Z","comments":true,"path":"0201/06/15/call&apply/","link":"","permalink":"http://www.hefang.site/0201/06/15/call&apply/","excerpt":"","text":"this &amp;&amp; arguments1234567function fn() &#123; console.log(this) console.log(arguments)&#125;fn() //window //[]//一般情况下 如果this 没有指定对象，那么就会指向全局 window//arguments 是代表实参，如果没有参数的传递 默认值就是一个伪数组 call this 为什么必须是对象因为 this 就是函数与对象之间的羁绊 123456789101112var person = &#123; name: &apos;frank&apos;, sayHi: function(person)&#123; console.log(&apos;Hi, I am&apos; + person.name) &#125;, sayBye: function(person)&#123; console.log(&apos;Bye, I am&apos; + person.name) &#125;, say: function(person, word)&#123; console.log(word + &apos;, I am&apos; + person.name) &#125; &#125; 看上面代码 我们通常会把person.name 改写成 this.name 但是如果JS里面 没有this 我们就只可以写成person.name，就像上面一样，这样写有一个好处，令阅读者更加清晰知道，你要打印出哪个name。 这样说，我们写代码就完成可以不用this。123456789101112131415161718192021222324252627//如果用this 我们会这样打印person.sayHi()person.sayBay()person.say(&apos;你好&apos;)//可是这样源码就要改变var person = &#123; name: &apos;frank&apos;, sayHi: function()&#123; console.log(&apos;Hi, I am&apos; + this.name) &#125;, sayBye: function()&#123; console.log(&apos;Bye, I am&apos; + this.name) &#125;, say: function(word)&#123; console.log(word + &apos;, I am&apos; + this.name) &#125; &#125;//如果不用this 我们可以这样打印person.sayHi(person)person.say(person)person.say(person,&apos;你好&apos;)//同样 我们可以用call 更清晰的打印person.sayHi.call(person)person.sayBay.call(person)person.say.call(person,&apos;你好&apos;) this 是call 的第一个参数 所以 我们在调用的时候 才能知道this 指向谁,所以this其实很不靠谱 我们还会经常疑惑的一种写法123var fn = person.sayHiperson.sayHi() // this === personfn() // this === window call 和 apply 的区别1234567891011121314function fn()&#123; var n = 0 for(var i = 0; i&lt;arguments.length; i++)&#123; n += arguments[i] &#125; return n&#125;//如果给出的参数是一个数组 而我们想数组的值相加//用call 就会有点鸡肋var a = [1,2,3,4,5]fn.call(null,a[0],a[1]....) //傻逼才会这样做//这时候我们就用applyfn.apply(null,a) //applay的第二参数是一个数组","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]}]}