{"meta":{"title":"he'blog","subtitle":null,"description":null,"author":"何方","url":"http://www.hefang.site","root":"/"},"pages":[{"title":"关于","date":"2018-11-30T16:52:39.000Z","updated":"2019-05-22T01:43:49.942Z","comments":true,"path":"about/index.html","permalink":"http://www.hefang.site/about/index.html","excerpt":"","text":""},{"title":"归档","date":"2018-11-30T17:12:43.000Z","updated":"2019-05-22T04:20:31.527Z","comments":true,"path":"archives/index.html","permalink":"http://www.hefang.site/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-30T16:52:39.000Z","updated":"2019-05-22T01:42:21.441Z","comments":true,"path":"categories/index.html","permalink":"http://www.hefang.site/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2018-09-01T06:21:57.000Z","updated":"2019-05-22T01:43:15.717Z","comments":true,"path":"resources/index.html","permalink":"http://www.hefang.site/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-30T17:12:43.000Z","updated":"2019-05-22T01:42:14.097Z","comments":true,"path":"tags/index.html","permalink":"http://www.hefang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js基本知识","slug":"js基本知识","date":"2019-06-23T12:27:29.000Z","updated":"2019-06-24T15:15:34.774Z","comments":true,"path":"2019/06/23/js基本知识/","link":"","permalink":"http://www.hefang.site/2019/06/23/js基本知识/","excerpt":"","text":"JavaScript 定义了几种数据类型? 哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么?1.JavaScript 定义了几种数据类型? 一共有6种，分别是： 数值(number)：整数和小数；字符串(string)：字符组成的文本；布尔值(boolean)：true（真），flase（假）；underfined：表示未定义，不存在。null：空值，但不代表不存值。对象（object）：各种值的组合集合； 2.哪些是原始类型?数值，字符串，布尔值，称为原始类型的值，也叫基本类型。即它们是最基本的数据类型，不能再细分。 3.哪些是复杂类型？对象就是复杂类型，也叫做引用类型，因为对象往往是多个原始类型的值的合成，可以看作是一个存放各种值得容器。 对象细分为: 侠义的对象。 数组（Array） 函数（function） 正则表达式 ps：underfined和null一般看作是两个特殊的值。 4.原始类型和复杂类型有什么区别？ 基本类型一般存放于栈内存，是一个单一的值。 引用类型存放于堆内存中。用一个变量，放在栈内存中，指明它的地址。是一个包含各种值得容器。 typeof和instanceof的作用和区别? typeof： 一般用来检测基本类型是什么类型，例如：123``` 得到的值就是```number```。可是如果检测引用类型的话就会返回```object```，不能明确区分到底是```&#123;&#125;``` 还是数组```[]```。(检测函数的时候会返回```funtion```)123456789ps：```typeof null``` 是```object```，```typeof underfined``` 得到的是```underfined```。- instanceof：用来检测对象到底是数组```[]```，还是```&#123;&#125;```。### 如何判断一个变量是否是数字、字符串、布尔、函数?&gt; ```typeof 123 //number 'hello'link1```typeof true //boolean f()&#123;&#125; typeof flink12345678### NaN是什么? 有什么特别之处?- NaN本身是一个Number，基本类型。（我是一个数据类型，但是我不是一个有效的数据！！！！！！！！！！！！）- NaN含义是Not a Number，表示非数字，NaN和任何值都不相等，包括自己。### 如何把非数值转化为数值?- parseInt() （如果遇到小数点，会把小数向下约等于，转换为整数。 ）```parseInt(&apos;123&apos;) // 123 // 3```12- parseFloat() （如果遇到小数，会保留小数，转换为数据类型。）``` parseFloat(&apos;3.4&apos;) // 3.4 ==与===有什么区别? ==： 是近似等于。 == 在比较的时候可以转自动换数据类型 ===： 是绝对等于。 === 严格比较，不会进行自动转换，要求进行比较的操作数必须类型一致，不一致时返回flase。 break与continue有什么区别？ break是立即跳出循环。 continue 是跳出本次循环。执行下次循环。 void 0 和 undefined在使用场景上有什么区别? void 会执行后面的表达式并返回 undefined，是一个纯正的undefined； underfined可以在局部作用域被赋值，复写。","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"string Array方法总结","slug":"string Array方法总结","date":"2019-06-23T12:27:29.000Z","updated":"2019-06-23T15:29:37.813Z","comments":true,"path":"2019/06/23/string Array方法总结/","link":"","permalink":"http://www.hefang.site/2019/06/23/string Array方法总结/","excerpt":"","text":".toUpperCase() 变成大写123var a=&quot;string&quot;var b=a.toUpperCase()console.log(b)//&quot;STRING&quot; .toLowerCase() 变成小写123var a=&quot;STRING&quot;var b=a.toLowerCase()console.log(b)//&quot;string&quot; .split() 以括号里面的内容为分界点，让字符串变为数组1234567891011121314例子1：var a=&quot;string-ing&quot;var b=a.split(&quot;-&quot;)console.log(b)//[&quot;string&quot;,&quot;ing&quot;]例子2：var a=&quot;string&quot;var b=a.split()//可以不写东西console.log(b)//[&quot;string&quot;]例子3var a=&quot;string&quot;var b=a.split(&quot;&quot;)console.log(b)//[&quot;s&quot;, &quot;t&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;]; .join() 让数组以括号里面的内容合并成一个字符串12345678var a=[1,2,3,4,5,6]var b=a.join(&quot;&quot;)console.log(b)//123456例子2：var a=[1,2,3,4,5,6]var b=a.join()console.log(b)//1,2,3,4,5,6 substr() 获取字符串指定的部分123456var a=&quot;string&quot;var b=a.substr(1,2)//获取了从1开始的后面2个字符串，包括1////如果省略第二个参数，会自动获取到最后console.log(b)//trconsole.log(a)//&quot;string&quot; 这个方法不会对原字符串做出任何修改 substring() 获取字符串指定的部分123456var a=&quot;string&quot;var b=a.substring(1,2)//获取了从1开始的后面2个字符串，这个不包括1//如果省略第二个参数，会自动获取到最后console.log(b)//jconsole.log(a)//&quot;string&quot; 这个方法不会对原字符串做出任何修改 reverse()把数组翻转123var a=[1,2,3,4,5];var b=a.reverse()console.log(b)//[5,4,3,2,1] toString//把数组变成字符串，就用逗号隔开123var a=[1,2,3,4,5,6]var b=a.toString()console.log(b)//1,2,3,4,5,6 splice() 切取数组的值（会改变原来的数组）1234var a=[1,2,3,4,5,6]var b=a.splice(0,1,2)//从0开始索引，窃取1位数，会包括0，然后把窃取的位置添加2console.log(b)//[1]console.log(a)//[2,2,3,4,5,6] slice()窃取数组的元素，不会改变原数组。1234var a=[1,2,3,4,5,6]var b=a.slice(0,3)包括第0位，从第0位开始窃取后面的三个元素。不会改变原数组console.log(b)//[1,2,3]console.log(a)//[1,2,3,4,5,6] push() / pop() 从数组后面添加元素 / 从数组后面删除元素 （都会改变原数组）12345var a=[1,2,3,4,5,6]a.push(7)console.log(a)//[1,2,3,4,5,6,7]a.pop()console.log(a)//[1,2,3,4,5,6] unshift() / shift() 从数组前端添加元素 / 从数组前端删除元素 （都会改变原数组）12345var a=[1,2,3,4,5,6]a.unshift(7)console.log(a)//[7,1,2,3,4,5,6]a.shift() console.log(a)//[1,2,3,4,5,6]","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"正则表达式汇总","slug":"正则表达式汇总","date":"2019-06-22T10:27:29.000Z","updated":"2019-06-22T14:30:14.944Z","comments":true,"path":"2019/06/22/正则表达式汇总/","link":"","permalink":"http://www.hefang.site/2019/06/22/正则表达式汇总/","excerpt":"","text":"1.正则表达式一般命名为regex2.JS正则表达式常用的方法12345RegExpObject.test(string) //方法用于检测一个字符串是否匹配某个模式.stringObject.match(regexp) //方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配RegExpObject.exec(string) //方法用于检索字符串中的正则表达式的匹配。 方法举例12345let regex = /\\d/let str = 123123let str2 = &apos;cwh&apos;regex.test(str) //trueregex.test(str2)//false 123var regex = /(\\d&#123;4&#125;)\\S(\\d+)[-](\\d+)/var str = &apos;2017-1-12&apos;str.match(regex) // [&apos;2017&apos;,&apos;2017&apos;,&apos;1&apos;,&apos;12&apos;] 123var regex = /\\d/var str = 123123123regex.exec(str) // [1],[2],[3],[1]...[null],[1].... 3.常用限定符号 代码语法 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或者1次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 4.常用元字符 代码语法 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 5.常用的反义代码 代码语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这个几个字母以外的任意字符 6.编辑器如何用正则 代码解析 匹配div 匹配任意的空白符 匹配class 保留div 保留class 直接替换掉空格 注意： 有时候替换符是/1 又或者是 $","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"css常见样式","slug":"解析白屏和FOUC","date":"2019-06-11T14:11:29.000Z","updated":"2019-06-11T15:36:14.111Z","comments":true,"path":"2019/06/11/解析白屏和FOUC/","link":"","permalink":"http://www.hefang.site/2019/06/11/解析白屏和FOUC/","excerpt":"","text":"解析白屏和FOUC白屏：1.css导致 如果把样式放在底部，对于IE浏览器，某些场景下（打开新的窗口，刷新页面）时会出现白屏，而不是逐步展现内容； 如果使用@import标签，即使CSS放在头部，用link引入，也有可能出现白屏。 白屏产生的原因和浏览器的渲染机制有关，在painting之前的步骤上有时间的延迟，主要是CSS加载的延迟。 2.js导致： 把JS放在顶部可能会导致白屏。 对于图片和CSS，在加载时会并发加载（如同个域名下同时加载两个文件），但在加载JS时，会禁用并发（脚本会阻塞后面内容的呈现几后面组件的加载），所以把JS放在页面顶部会导致白屏现象。 FOUC： FOUC（Flash Of Unstyled Content，文档样式闪烁）, 产生的原因：如果把css放在底部，对于IE浏览器，对于某些场景，就会出现FOUC现象，对于firfox会一直表现FOUC， 解决办法：把link放在头部。 把@import换成link引入","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"深拷贝函数","slug":"深拷贝函数","date":"2019-05-29T12:27:29.000Z","updated":"2019-05-29T13:44:59.187Z","comments":true,"path":"2019/05/29/深拷贝函数/","link":"","permalink":"http://www.hefang.site/2019/05/29/深拷贝函数/","excerpt":"","text":"第一种:function copy(obj){ var newObject={}; for (var key in obj) { if(typeof obj[key] === &apos;number&apos;||typeof obj[key] === &apos;boolean&apos;||typeof obj[key] === &apos;string&apos;||obj[key] ===undefined||obj[key] === null){ newObject[key]=obj[key]; } else{ newObject[key]=copy(obj[key]) } } return newObject; } 第二种:var cloneObj = JSON.parse(JSON.stringify(obj));","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"css常见样式2","slug":"css常见样式2","date":"2019-05-26T10:27:29.000Z","updated":"2019-05-26T11:02:37.241Z","comments":true,"path":"2019/05/26/css常见样式2/","link":"","permalink":"http://www.hefang.site/2019/05/26/css常见样式2/","excerpt":"","text":"1.text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中 作用在行内元素上，实现行元素居中。 2. IE盒子模型和W3C盒子模型有什么区别？ IE 的盒子模型content 中包含了border和padding W3C的盒子模型content是不包括border和padding的 3、 { box-sizing: border-box;}的作用是什么？ 转换为IE的盒子模型，就是内容包括了border和padding{ box-sizing: content-box;}的作用是什么？ 默认值了，就是普通的W3C盒子模型。 4.line-height: 2和line-height: 200%有什么区别? line-height: 200%：当前字体尺寸的百分之两百设置行间距。 line-height: 2： 数字会与当前的字体尺寸相乘来设置行间距。 5.inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? inline-block：对象为内联对象，但是对象的内容可以作为块对象操作。(简单认为，可以设置大小的内联元素) 如何去除缝隙： 1.你可以把标签与标签之间的空格全部删除，但是这样不美观。2.在父元素设置，font-size：0；然后在你想设置的元素上再重新设置font-size：；(简单点说就是将空白字符的高度都设置为0)；3.高度不一样的inline-block元素如何顶端对齐：vertical-align: top; 6.CSS sprite 是什么? 简称雪碧图 你上去淘宝看看那些一个一个的icon就是雪碧图 优点：减少网页的http请求，从而大大的提高页面的性能 7.让一个元素”看不见”有几种方式？有什么区别? 方法 区别 opacity：0； 改变了透明度，让你看不见了。 还存在 display: none; 会让选中的元素直接删除； visibility：hidden； 类似于 opacity 还存在 background：rbga(0，0，0，0.2) 也是改变背景颜色，和透明度 还存在","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"css常见样式","slug":"css常见样式","date":"2019-05-24T14:10:29.000Z","updated":"2019-05-24T14:44:36.941Z","comments":true,"path":"2019/05/24/css常见样式/","link":"","permalink":"http://www.hefang.site/2019/05/24/css常见样式/","excerpt":"","text":"1.块级元素和行内元素分别有哪些？块级元素：div，h1~h6，table，form，header， footer，nav，ul，li，ol，dl。。。。。行内元素：a，input，span，i，img，strong， select。。。。。 2.动手测试并列出4条以上的特性区别。 块级元素 行内元素 没有设置宽度的情况下，默认占据一整行 内容有多宽，我就有多宽 可以随便设置宽高 不可以 随便设置padding，margin padding和margin只可以设置左右 可以包裹块级元素，行内元素 我只能包裹文本，和行内元素 3.什么是 CSS 继承? 哪些属性能继承，哪些不能？CSS继承，就是子元素继承了父元素的属性。 能继承 不能继承 letter-spacing height word-spacing min-height white-space max-height line-height width color min-width font max-width font-style float font-family position text-align overflow text-indent vertical-align font-weight clear 等等等等 等等等等 4.如何让块级元素水平居中？如何让行内元素水平居中?块级元素水平居中：margin：0 auto；行内元素水平居中：text-align：center； 5.单行文本溢出加…….如何实现？E{white-space:nowrap;overflow:hidden;text-overflow;} 6.px, em, rem 有什么区别 px：固定尺寸； em： 相对于当前对象内文本的字体尺寸 rem： 相对于HTML的相对大小 7.解释下面代码的作用?为什么要加引号? 字体里\\5b8b\\4f53代表什么?body{ font: 12px/1.5 tahoma,arial,’Hiragino Sans GB’,’\\5b8b\\4f53’,sans-serif;} 1.设置body字体大小为12px，行高是字体1.5倍的像素值，后面则是第一到第五字体，用逗号隔开，如果第一个你电脑没有，则运行第二个。2.加引号是因为，字体间有空格，这样会识别为不同的两个单词，所以加空格。3.字体那些代码代表“宋体” ps:在浏览器console里输入escape（”你想要的字体编码”），就能出现像想要的代码记住将%u改成/。","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"flex","slug":"flex","date":"2019-05-22T10:27:29.000Z","updated":"2019-05-22T12:23:42.002Z","comments":true,"path":"2019/05/22/flex/","link":"","permalink":"http://www.hefang.site/2019/05/22/flex/","excerpt":"","text":"flex在学习flex只是之前，平时的demo中使用到的传统布局主要有以下几种： 1、normal flow 文档流、正常流2、float + clear 清除浮动3、position relative + absolute 相对 + 绝对定位4、display inline-block 横向布局5、负 margin 扩大宽度、产生位移 这些传统的布局方式虽然可以满足我们的很多需求，但是也并不方便，比如实现垂直居中。而现在我们就要开始接触flex布局这种新的布局方式了。flex也可称为“弹性布局”，flex布局有以下几个特点： 1、块级布局侧重垂直方向，行内布局侧重水平方向。flex布局与方向无关2、flex布局可以实现空间自动分配，自动对齐3、flex布局适用于简单的线性布局，复杂的布局则可以使用grid布局 接下来就将对flex布局的几个重要知识点进行归纳。 flex布局的基本概念采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）。 flex container 的属性flex container（flex容器）有如下六个属性：flex-direction,flex-wrap,flex-flow,jstify-content,align-items,align-content flex-direction 方向-属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。该属性主要有以下值：row,row-reverse,column,column-reverse, 以flex-direction:row-reverse为例： https://jsbin.com/kugepiposa/edit?html,css,output flex-wrap 指定 flex 元素单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。该属性主要有以下值： wrap,nowrap,wrap-reverse, 以flex-wrap:wrap;为例： https://jsbin.com/pugumitoli/1/edit?html,css,output flex-flow 上面两个属性的缩写默认值为row nowrap，可以以如下方法设定该属性： .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } justify-content 主轴方向的对齐方式space-between,space-around,flex-start,flex-end,center以justify-content:space-between为例： https://jsbin.com/jowuvubiju/1/edit?html,css,output align-items 侧轴方向的对齐方式stretch,flex-start,flex-end,center,baseline 以align-items:center为例： https://jsbin.com/pebevizeri/1/edit?html,css,output align-content 多行多列的对齐方式space-between，space-around，flex-start，flex-end，stretch， flex item 的属性flex item（子元素）有如下六个属性： order flex-grow flex-shrink flex-basis flex align-self flex-grow该属性默认值为0。如果所有子元素的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个子元素的flex-grow属性为2，其他子元素都为1，则前者占据的剩余空间将比其他项多一倍。 例子： https://jsbin.com/vayolutake/1/edit?html,css,output flex-shink 空间不足时的收缩比例该属性默认值为1。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 例子： https://jsbin.com/deriqobuwu/1/edit?html,css,output、 flex-basis 子元素的默认宽度flex-basis属性定义了在分配多余空间之前，子元素占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来宽度。 例子： https://jsbin.com/vivuserebe/1/edit?html,css,output 使用flex布局的几个技巧flex 布局可以简便、完整、响应式地实现各种页面布局。下面就简要地记录几个flex布局的技巧 实现手机布局如果内容被修剪，需要浏览器显示滚动条，以便查看剩余内容，可以使用 over-flow:auto;实现手机上中下布局： .content{ height:100vh; display:flex; flex-direction:column; } 实现电脑左中右布局 .content&gt;aside{width:120px;} .content&gt;main{height:400px;flex:1} .content&gt;nav{width:100px;} 完美居中 .parent{ display:flex; justify-content:center; align-items:center; }","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"常见排序算法","slug":"常见排序算法","date":"2019-05-21T06:51:00.000Z","updated":"2019-05-22T04:09:31.898Z","comments":true,"path":"2019/05/21/常见排序算法/","link":"","permalink":"http://www.hefang.site/2019/05/21/常见排序算法/","excerpt":"","text":"常见排序算法 - 冒泡排序 (Bubble Sort)冒泡排序算法的流程如下：1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3、针对所有的元素重复以上的步骤，除了最后一个。4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实例分析：以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：第一次外循环 ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置 ( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置 ( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置 ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列） ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变 ( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置 ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) JavaScript 语言实现function bubbleSort(array) { var length = array.length, i, j, temp; for (i = length - 1; 0 &lt; i; i--) { for (j = 0; j &lt; i; j++) { if (array[j] &gt; array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } return array; } 流程图预览地址 常见排序算法 - 选择排序 (Selection Sort)算法原理选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 实例分析：以数组 arr = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）： min ↓ 8 5 2 6 9 3 1 4 0 7 ↑ ↑ └───────────────────────────────┘ 交换后： 0 5 2 6 9 3 1 4 8 7 在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换： min ↓ 0 5 2 6 9 3 1 4 8 7 ↑ ↑ └───────────────────┘ 交换后： 0 1 2 6 9 3 5 4 8 7 在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）： min ↓ 0 1 2 6 9 3 5 4 8 7 ↑ 重复上述过程，直到最后一个元素就完成了排序。 min ↓ 0 1 2 6 9 3 5 4 8 7 ↑ ↑ └───────┘ min ↓ 0 1 2 3 9 6 5 4 8 7 ↑ ↑ └───────────┘ min ↓ 0 1 2 3 4 6 5 9 8 7 ↑ ↑ └───┘ min ↓ 0 1 2 3 4 5 6 9 8 7 ↑ min ↓ 0 1 2 3 4 5 6 9 8 7 ↑ ↑ └───────┘ min ↓ 0 1 2 3 4 5 6 7 8 9 ↑ min ↓ 0 1 2 3 4 5 6 7 8 9 ↑ JavaScript 语言实现function selectionSort(array) { var length = array.length, i, j, minIndex, minValue, temp; for (i = 0; i &lt; length - 1; i++) { minIndex = i; minValue = array[minIndex]; for (j = i + 1; j &lt; length; j++) { if (array[j] &lt; minValue) { minIndex = j; minValue = array[minIndex]; } } // 交换位置 temp = array[i]; array[i] = minValue; array[minIndex] = temp; } return array } 流程图预览地址","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"grid","slug":"grid","date":"2019-05-21T03:27:29.000Z","updated":"2019-05-23T04:24:38.699Z","comments":true,"path":"2019/05/21/grid/","link":"","permalink":"http://www.hefang.site/2019/05/21/grid/","excerpt":"","text":"grid网格布局可以将应用程序分割成不同的空间，定义它们的大小、位置和层级。 简单来说，网格布局就像表格一样可以让元素按列和行对齐排列，不同的是，网格布局没有内容结构，比如一个网格布局的子元素可以定位自己的位置，可以是实现类似定位的效果。 兼容性caniuse可以看到几大浏览器都已经支持了Grid布局 grid vs flex我们知道flex和grid都是css3新的布局方式，如果浏览器都支持两种布局，你会选择那种呢？当我们了解两者以后就能做出正确的选择了。 flex布局是一维布局，grid布局是二维布局。 Grid属性分为两类，一类作用于grid容器，一类作用于grid子项目上。属性繁多，按需选用。 作用于grid容器 grid-template-columns grid-template-rows grid-template-areas grid-template grid-column-gap grid-row-gap grid-gap justify-items align-items place-items justify-content align-content place-content grid-auto-columns grid-auto-rows grid-auto-flow grid作用于grid子项目作用于grid子项目 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self place-self 举例几种布局：1、左右固定，中间自适应预览地址 2、九宫格预览地址 大多数网站布局预览地址 总结来说： CSS Grid 是一个二维的布局系统CSS Grid 相比传统布局在页面整体划分布局上更加出色CSS Grid 并不是只能单独使用，依然可以搭配Flexbox以及传统定位布局一起使用","categories":[{"name":"css","slug":"css","permalink":"http://www.hefang.site/categories/css/"}],"tags":[]},{"title":"原型与原型链","slug":"原型与原型链","date":"2018-12-11T02:44:29.000Z","updated":"2019-05-22T04:09:13.949Z","comments":true,"path":"2018/12/11/原型与原型链/","link":"","permalink":"http://www.hefang.site/2018/12/11/原型与原型链/","excerpt":"","text":"例子1function Person(name){ this.name = name; this.age = age; } Person.prototype.sayName = function(){ console.log(this.name); } var p1 = new Person(&apos;a&apos;); var p2 = new Person(&apos;b&apos;); p1.sayName(); p2.sayName(); 1.new 一个函数本质上做了什么？ 1)创建了一个空的对象 2)空对象的proto指向了类Modal()的prototype 3)在执行函数的过程中，给this赋值，函数里的this代表了空对象，返回出去 4)将this赋值给modal2.通过函数定义了一个类Person，它自动获取了属性prototype，每个类的实例也就是p1、p2内部都会有一个proto的属性，如下图: 例子2当前的p1实例，查找toString()的方法先从p1的属性里找，没有找到,再从 p1.proto 中找，没有找到,再从 p1.proto.proto 中找，找到后返回 例子3function People(){} var p = new People() p.__proto__ === People.prototype People.__proto__ === Function.prototype People.prototype.__proto__ === Object.prototype （1）People函数创建了对象 p，所以People.prototype === p.proto；（2）Object函数创建了People.prototype对象，所以Object.prototype === People.prototype.proto；（3）People 作为对象的角色被函数Function创建，所以 Function.prototype === People.proto; 例子4（1）任何函数都是 Function 创建，所以Function 创建了 Function，所以 Function.prototype === Function.proto；（2）Object 也是函数。所以Function创建了Object，所以 Function.prototype === Object.proto ；（3）Function.prototype 是普通对象，普通对象是由Object创建的，所以 Function.prototype.proto === Object.prototype 例子5Object instanceof Function Function instanceof Object Function instanceof Function Object instanceof Object instanceof的作用是判断一个对象是不是一个函数的实例。比如obj instanceof fn,实际上是判断fn的prototype是不是在obj的原型链上。比如: obj.__proto__ === fn.prototype obj.__proto__.__proto__ === fn.prototype obj.__proto__..._proto__ === fn.prototype 只要一个成立即可。1.对于Function instanceof Function,因为 Function.proto === Function.prototype所以为true。 2.对于Object instanceof Object,因为 Object.proto.proto === Function.prototype.proto === Object.prototype,所以为true 3.对于Function instanceof Object,因为 Function.proto.proto === Function.prototype.proto === Object.prototype,所以为true 4.对于Object instanceof Function,因为 Object.proto === Function.prototype所以为true","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"动画队列","slug":"动画队列","date":"2018-10-26T10:27:29.000Z","updated":"2019-05-22T04:09:09.298Z","comments":true,"path":"2018/10/26/动画队列/","link":"","permalink":"http://www.hefang.site/2018/10/26/动画队列/","excerpt":"","text":"动画队列jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。 .stop( [clearQueue ] [, jumpToEnd ] )（添加版本1.2）clearQueue类型: Boolean一个布尔值，指示是否取消以列队动画。默认 false.jumpToEnd类型: Boolean一个布尔值指示是否当前动画立即完成。默认false. .stop( [queue ] [, clearQueue ] [, jumpToEnd ] )（添加版本1.7）queue类型: String停止动画队列的名称。clearQueue类型: Boolean一个布尔值，指示是否取消以列队动画。默认 false.jumpToEnd类型: Boolean一个布尔值指示是否当前动画立即完成。默认false.jQuery中有stop这个方法可以停止当前执行的动画，并且它有两个布尔参数，默认值都为false。 clearQueue(default: false) jumpToEnd(default: false) 第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以，我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后面的队列丢弃了，这就会出现意料之外的结果。 ###我们可以看到如下整理结果: 方法 参数 说明 stop() 清空队列，当前执行动作立即停止。后续动作会不再执行。 等同于：stop(false,false) stop(true) [clearQueue] 清空队列，当前执行动作立即停止。后续动作会不再执行 stop(true,true) [clearQueue],[gotoEnd] 清空队列，当前执行动作立即完成。后续动作会不再执行 stop(true,false) [clearQueue],[gotoEnd] 清空队列，当前执行动作立即停止。后续动作会不再执行 stop(false) [clearQueue] 不清空队列，当前执行动作立即停止。后续动作会立即执行 stop(false,true) [clearQueue],[gotoEnd] 不清空队列，当前执行动作立即完成。后续动作会立即执行 stop(false,false) [clearQueue],[gotoEnd] 不清空队列，当前执行动作立即停止。后续动作会立即执行","categories":[{"name":"jquery","slug":"jquery","permalink":"http://www.hefang.site/categories/jquery/"}],"tags":[]},{"title":"CORS","slug":"跨域(CORS)","date":"2018-10-02T08:27:29.000Z","updated":"2019-05-22T04:09:43.265Z","comments":true,"path":"2018/10/02/跨域(CORS)/","link":"","permalink":"http://www.hefang.site/2018/10/02/跨域(CORS)/","excerpt":"","text":"cors为什么要跨域？跨域问题是浏览器同源策略限制，当前域名的js只能读取同域下的窗口属性。一个网站的网址组成包括协议名，子域名，主域名，端口号。比如 https://www.github.com/80，其中https是协议名,www.github.com是子域名，github.com是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在http://localhost:80/ 页面请求http://127.0.0.1:80 也会有跨域问题（因为域名不一样嘛~） 跨域的实现的几种方式1、Jsonp最常见的一种跨域方式，其背后的原理就是利用script标签不受同源策略的限制，在页面中动态插入script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理的函数名名告诉后端，后端在响应请求时会将函数回调返回，并且将数据以参数的形式传递回去代码部分： &lt;script&gt; function showData(ret){ console.log(ret); } &lt;/script&gt; 2、CORS当使用XMLHttpRequest发送请求是，如果浏览器发现了违反了同源策略就会自动加上一个请求头：origin，后端在接受请求的时候确定响应后会在Response Headers中加入一个熟悉：Access-Control-Allow-Origin，value就是发起请求的源地址 http://127.0.0.1:8080，浏览器得到响应会继续判断Access-Control—Allow—Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理 var http = require(&apos;http&apos;) var fs = require(&apos;fs&apos;) var path = require(&apos;path&apos;) var url = require(&apos;url&apos;) http.createServer(function(req,res){ var pathObj = url.parse(req.url,true) switch(pathObj.pathname){ case &apos;/getWeather&apos;: var weather =[ &quot;beijing&quot;:&quot;sunny&quot;, &quot;shanghai&quot;:&quot;cloudy&quot; ] res.setHeader(&apos;Access-Control-Allow-Origin&apos;,http://localhost:8080) res.end(JSON.stringify(weather)) break; default: fs.readFile(parse.join(__dirname,pathObj.pathname),function(e,data){ if(e){ res.writeHead(404, &apos;not found&apos;) res.end(&apos;&lt;h1&gt;404 not found&lt;/h1&gt;&apos;) }else{ res.end(data) } }) } }).listen(8080) $(&apos;.change&apos;).addEventListener(&apos;click&apos;, function () { var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, &apos;http://localhost:8080/getWeather&apos;, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { appendHtml(JSON.parse(xhr.responseText)) } }; }); 2、window.postMessage(message,targetOrigin)方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。这种方法不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据","categories":[{"name":"http","slug":"http","permalink":"http://www.hefang.site/categories/http/"}],"tags":[]},{"title":"cookie&session&localStorage","slug":"cookie&session&localStorage","date":"2018-09-15T12:27:29.000Z","updated":"2019-05-26T10:58:34.360Z","comments":true,"path":"2018/09/15/cookie&session&localStorage/","link":"","permalink":"http://www.hefang.site/2018/09/15/cookie&session&localStorage/","excerpt":"","text":"cookie&amp;session&amp;localStorage一、cookiecookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。在控制台用 「document.cookie」查看你当前正在浏览的网站的cookie。cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用 HTTP 协议规定的 set-cookie 来让浏览器种下cookie，这是最常见的做法。（打开一个网站，清除全部cookie，然后刷新页面，在network的Response headers试试找一找set-cookie吧）每次网络请求 Request headers 中都会带上cookie。所以如果 cookie 太多太大对传输效率会有影响。一般浏览器存储cookie 最大容量为4k，所以大量数据不要存到cookie。设置cookie时的参数：path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。expires 和 maxAge：告诉浏览器 cookie 时候过期，maxAge 是 cookie 多久后过期的相对时间。不设置这两个选项时会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。[cookie 参数][简述 Cookie 是什么] 二、session当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个session用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。创建session后，会把关联的session_id 通过setCookie 添加到http响应头部中。浏览器在加载页面时发现响应头部有 set-cookie字段，就把这个cookie 种到浏览器指定域名下。当下次刷新页面时，发送的请求会带上这条cookie， 服务端在接收到后根据这个session_id来识别用户。cookie 是存储在浏览器里的一小段「数据」，而session是一种让服务器能识别某个用户的「机制」，session 在实现的过程中需要使用cookie。当然有时候说到 session 也指服务器里创建的那个和用户身份关联的对象。 三、localStoragelocalStorage HTML5本地存储web storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。不参与网络传输。一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"HTMLCollection 和 NodeList","slug":"HTMLCollection 和 NodeList","date":"2018-09-04T10:27:29.000Z","updated":"2019-05-22T04:11:15.493Z","comments":true,"path":"2018/09/04/HTMLCollection 和 NodeList/","link":"","permalink":"http://www.hefang.site/2018/09/04/HTMLCollection 和 NodeList/","excerpt":"","text":"HTMLCollection 和 NodeList节点都是单个对象，有时会需要一种数据结构，能够容纳多个节点。DOM提供两种集合对象，用于实现这种节点的集合：NodeList和HTMLCollection。 NodeList 对象代表一个有顺序的节点列表，HTMLCollection 是一个接口，表示 HTML 元素的集合，它提供了可以遍历列表的方法和属性 以下方法获取的为HTMLCollection对象 document.images //所有img元素 document.links //所有带href属性的a元素和area元素 document.forms //所有form元素 document.scripts //所有script元素 document.body.children document.getElementsByClassName(&quot;class1&quot;) 以下方法获取的为NodeList对象 document.getElementsByName(&quot;name1&quot;) document.getElementsByTagName(&quot;a&quot;) document.querySelectorAll(&quot;a&quot;) document.body.childNodes 如何查看？ document.body.childNodes.constructor HTMLCollection与NodeList基本相似 相同点： 都是类数组对象，节点的变化都会实时反映在集合中 不同点： 少部分方法不一样，比如 NodeList 有 forEach 方法，而 HTMLCollection 没有","categories":[{"name":"other","slug":"other","permalink":"http://www.hefang.site/categories/other/"}],"tags":[]},{"title":"随机生成ip、字符串、color","slug":"随机生成IP、字符串、颜色等","date":"2018-09-01T12:44:29.000Z","updated":"2019-05-22T04:09:52.683Z","comments":true,"path":"2018/09/01/随机生成IP、字符串、颜色等/","link":"","permalink":"http://www.hefang.site/2018/09/01/随机生成IP、字符串、颜色等/","excerpt":"","text":"随机生成ip、字符串、color//随机生成32位字符串 function getRandomStr(len) { var a = &apos;&apos; var b =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot; for (i = 0 ; i &lt;len; i++){ var c = Math.floor(Math.random()*b.length) a += b[c] } return a } var a = getRandomStr(32) console.log(a) //随机生成一个IP地址 function getRandIP(){ var ip=[] for (i= 0 ; i&lt;4; i++){ ip[i]= Math.floor(Math.random()*256) } return ip.join(&apos;.&apos;) } var ip = getRandIP() console.log(ip) //生成一个随机颜色字符串 function getRandColor(){ var color = &apos;#&apos; var dict =&apos;0123456abcdef&apos; for(i = 0; i &lt; 6; i++){ var index =Math.floor(Math.random()*dict.length) color += dict[index] } return color } var color = getRandColor() console.log(color) //min到max之间的 随机整数 function sum(min,max){ var sum =Math.floor(Math.random()*(max-min))+min return sum } console.log(sum(1,100))","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"实现一个flatten函数","slug":"实现一个flatten函数","date":"2018-09-01T04:44:29.000Z","updated":"2019-05-22T04:09:22.563Z","comments":true,"path":"2018/09/01/实现一个flatten函数/","link":"","permalink":"http://www.hefang.site/2018/09/01/实现一个flatten函数/","excerpt":"","text":"实现一个flatten函数实现一个flatten函数，将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组，数组中元素仅基本类型的元素或数组，不存在循环引用的情况。 Ex: flatten([1, [2], [3, [[4]]]]) =&gt; [1, 2, 3, 4]; //方法1 var arr = ([1, [2], [3, [[4]]]]) function flatten(arr){ var newArr = [] function _flat(arr){ arr.forEach(val=&gt;{ if(Array.isArray(val)){ _flat(val) }else{ newArr.push(val) } }) } _flat(arr) return newArr } //方法2 var arr = ([1, [2], [3, [[4]]]]) function flatten2(arr){ return arr.reduce(function(initArr, currentArr){ return initArr.concat(Array.isArray(currentArr)?flatten2(currentArr):currentArr) }, []) } console.log(flatten2(arr)) //[1, 2, 3, 4]","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"JavaScript专题之数组扁平化","slug":"数组扁平化","date":"2018-08-31T02:44:29.000Z","updated":"2019-05-22T04:09:37.594Z","comments":true,"path":"2018/08/31/数组扁平化/","link":"","permalink":"http://www.hefang.site/2018/08/31/数组扁平化/","excerpt":"","text":"扁平化数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。 举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下： var arr = [1, [2, [3, 4]]]; console.log(flatten(arr)) // [1, 2, 3, 4] 知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了 递归我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法： // 方法 1 var arr = [1, [2, [3, 4]]]; function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) { if (Array.isArray(arr[i])) { result = result.concat(flatten(arr[i])) } else { result.push(arr[i]) } } return result; } console.log(flatten(arr)) toString如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为： [1, [2, [3, 4]]].toString() // “1,2,3,4”调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？ // 方法2 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.toString().split(&apos;,&apos;).map(function(item){ return +item }) } console.log(flatten(arr)) 然而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，这种方法就会产生错误的结果。 reduce既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码： // 方法3 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.reduce(function(prev, next){ return prev.concat(Array.isArray(next) ? flatten(next) : next) }, []) } console.log(flatten(arr)) …ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： var arr = [1, [2, [3, 4]]];console.log([].concat(…arr)); // [1, 2, [3, 4]]我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： // 方法4 var arr = [1, [2, [3, 4]]]; function flatten(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flatten(arr)) undercore那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~ 在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。 /** 数组扁平化 @param {Array} input 要处理的数组 @param {boolean} shallow 是否只扁平一层 @param {boolean} strict 是否严格处理元素，下面有解释 @param {Array} output 这是为了方便递归而传递的参数 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528*/ function flatten(input, shallow, strict, output) { // 递归使用的时候会用到output output = output || []; var idx = output.length; for (var i = 0, len = input.length; i &lt; len; i++) { var value = input[i]; // 如果是数组，就进行处理 if (Array.isArray(value)) { // 如果是只扁平一层，遍历该数组，依此填入 output if (shallow) { var j = 0, length = value.length; while (j &lt; length) output[idx++] = value[j++]; } // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output else { flatten(value, shallow, strict, output); idx = output.length; } } // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output else if (!strict){ output[idx++] = value; } } return output; } 解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子： var arr = [1, 2, [3, 4]];console.log(flatten(arr, true, true)); // [3, 4]那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果： shallow true + strict false ：正常扁平一层shallow false + strict false ：正常扁平所有层shallow true + strict true ：去掉非数组元素shallow false + strict true ： 返回一个[]我们看看 underscore 中哪些方法调用了 flatten 这个基本函数： _.flatten首先就是 _.flatten： _.flatten = function(array, shallow) { return flatten(array, shallow, false);};在正常的扁平中，我们并不需要去掉非数组元素。 _.union接下来是 _.union： 该函数传入多个数组，然后返回传入的数组的并集， 举个例子： _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);=&gt; [1, 2, 3, 101, 10]如果传入的参数并不是数组，就会将该参数跳过： _.union([1, 2, 3], [101, 2, 1, 10], 4, 5);=&gt; [1, 2, 3, 101, 10]为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。 // 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27) function unique(array) { return Array.from(new Set(array)); } _.union = function() { return unique(flatten(arguments, true, true)); } _.difference是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference： 语法为： _.difference(array, *others) 效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。 举个例子： _.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);=&gt; [1, 3]实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值： function difference(array, ...rest) { rest = flatten(rest, true, true); return array.filter(function(item){ return rest.indexOf(item) === -1; }) }","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"js作用域","slug":"js作用域相关介绍","date":"2018-08-27T15:27:29.000Z","updated":"2019-05-22T04:08:49.404Z","comments":true,"path":"2018/08/27/js作用域相关介绍/","link":"","permalink":"http://www.hefang.site/2018/08/27/js作用域相关介绍/","excerpt":"","text":"JavaScript的作用域是什么作用域，在维基百科上解释是：在电脑程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： (1）程序最外层定义的函数或者变量var a = “tsrot”;function hello(){ alert(a);} function sayHello(){ hello();} alert(a); //能访问到tsrothello(); //能访问到tsrotsayHello(); //能访问到hello函数，然后也能访问到tsrot（2）所有末定义直接赋值的变量（不推荐）function hello(){ a = “tsrot”; var b = “hello tsrot”;} alert(a); //能访问到tsrotalert(b); //error 不能访问（3）所有window对象的属性和方法一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。function hello(){ var a = “tsrot”; alert(a);} hello(); //函数内可访问到tsrotalert(a); //error not defined","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]},{"title":"浏览器的渲染机制","slug":"介绍浏览器的渲染机制","date":"2018-05-27T11:27:29.000Z","updated":"2019-05-22T04:29:48.977Z","comments":true,"path":"2018/05/27/介绍浏览器的渲染机制/","link":"","permalink":"http://www.hefang.site/2018/05/27/介绍浏览器的渲染机制/","excerpt":"","text":"浏览器的渲染机制首先当用户输入一个URL的时候，浏览器就会发送一个请求，请求URL对应的资源。然后浏览器的HTML解析器会将这个文件解析，并且构建成一棵DOM树。在构建DOM树的时候，遇到JS和CSS元素，HTML解析器就换将控制权转让给JS解析器或者是CSS解析器。JS解析器或者是CSS解析器解析完这个元素时候，HTML又继续解析下个元素，直到整棵DOM树构建完成。DOM树构建完之后，浏览器把DOM树中的一些不可视元素去掉，然后与CSSOM合成一棵render树。接着浏览器根据这棵render树，计算出各个节点(元素)在屏幕的位置。这个过程叫做layout，输出的是一棵layout树。最后浏览器根据这棵layout树，将页面渲染到屏幕上去。","categories":[{"name":"http","slug":"http","permalink":"http://www.hefang.site/categories/http/"}],"tags":[]},{"title":"cookie&session&localStorage","slug":"call&apply","date":"0201-06-15T12:21:46.000Z","updated":"2019-06-21T15:10:14.398Z","comments":true,"path":"0201/06/15/call&apply/","link":"","permalink":"http://www.hefang.site/0201/06/15/call&apply/","excerpt":"","text":"this &amp;&amp; arguments1234567function fn() &#123; console.log(this) console.log(arguments)&#125;fn() //window //[]//一般情况下 如果this 没有指定对象，那么就会指向全局 window//arguments 是代表实参，如果没有参数的传递 默认值就是一个伪数组 call this 为什么必须是对象因为 this 就是函数与对象之间的羁绊 123456789101112var person = &#123; name: &apos;frank&apos;, sayHi: function(person)&#123; console.log(&apos;Hi, I am&apos; + person.name) &#125;, sayBye: function(person)&#123; console.log(&apos;Bye, I am&apos; + person.name) &#125;, say: function(person, word)&#123; console.log(word + &apos;, I am&apos; + person.name) &#125; &#125; 看上面代码 我们通常会把person.name 改写成 this.name 但是如果JS里面 没有this 我们就只可以写成person.name，就像上面一样，这样写有一个好处，令阅读者更加清晰知道，你要打印出哪个name。 这样说，我们写代码就完成可以不用this。123456789101112131415161718192021222324252627//如果用this 我们会这样打印person.sayHi()person.sayBay()person.say(&apos;你好&apos;)//可是这样源码就要改变var person = &#123; name: &apos;frank&apos;, sayHi: function()&#123; console.log(&apos;Hi, I am&apos; + this.name) &#125;, sayBye: function()&#123; console.log(&apos;Bye, I am&apos; + this.name) &#125;, say: function(word)&#123; console.log(word + &apos;, I am&apos; + this.name) &#125; &#125;//如果不用this 我们可以这样打印person.sayHi(person)person.say(person)person.say(person,&apos;你好&apos;)//同样 我们可以用call 更清晰的打印person.sayHi.call(person)person.sayBay.call(person)person.say.call(person,&apos;你好&apos;) this 是call 的第一个参数 所以 我们在调用的时候 才能知道this 指向谁,所以this其实很不靠谱 我们还会经常疑惑的一种写法123var fn = person.sayHiperson.sayHi() // this === personfn() // this === window call 和 apply 的区别1234567891011121314function fn()&#123; var n = 0 for(var i = 0; i&lt;arguments.length; i++)&#123; n += arguments[i] &#125; return n&#125;//如果给出的参数是一个数组 而我们想数组的值相加//用call 就会有点鸡肋var a = [1,2,3,4,5]fn.call(null,a[0],a[1]....) //傻逼才会这样做//这时候我们就用applyfn.apply(null,a) //applay的第二参数是一个数组","categories":[{"name":"js","slug":"js","permalink":"http://www.hefang.site/categories/js/"}],"tags":[]}]}