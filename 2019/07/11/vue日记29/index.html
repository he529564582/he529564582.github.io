<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="JS笔记标识符 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9  下面这些都是合法的标识符:1234arg0_tmp$elemπ 下面这些则是不合法的标识符:123451a  // 第一个字符不能是数字23  // 同上***  // 标识符不">
<meta property="og:type" content="article">
<meta property="og:title" content="js笔记">
<meta property="og:url" content="http://www.hefang.site/2019/07/11/vue日记29/index.html">
<meta property="og:site_name" content="he&#39;blog">
<meta property="og:description" content="JS笔记标识符 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9  下面这些都是合法的标识符:1234arg0_tmp$elemπ 下面这些则是不合法的标识符:123451a  // 第一个字符不能是数字23  // 同上***  // 标识符不">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-17T07:47:50.112Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js笔记">
<meta name="twitter:description" content="JS笔记标识符 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9  下面这些都是合法的标识符:1234arg0_tmp$elemπ 下面这些则是不合法的标识符:123451a  // 第一个字符不能是数字23  // 同上***  // 标识符不">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.hefang.site/2019/07/11/vue日记29/">





  <title>js笔记 | he'blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">he'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hefang.site/2019/07/11/vue日记29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="何方">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="he'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T20:42:29+08:00">
                2019-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="JS笔记"><a href="#JS笔记" class="headerlink" title="JS笔记"></a>JS笔记</h2><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ol>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9</li>
</ol>
<p>下面这些都是合法的标识符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></table></figure></p>
<p>下面这些则是不合法的标识符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1a  // 第一个字符不能是数字</span><br><span class="line">23  // 同上</span><br><span class="line">***  // 标识符不能包含星号</span><br><span class="line">a+b  // 标识符不能包含加号</span><br><span class="line">-d  // 标识符不能包含减号或连词线</span><br></pre></td></tr></table></figure></p>
<p>中文是合法的标识符，可以用作变量名</p>
<h4 id="数据类型-（ES6-又新增了第七种-Symbol-类型的值"><a href="#数据类型-（ES6-又新增了第七种-Symbol-类型的值" class="headerlink" title="数据类型 ==（ES6 又新增了第七种 Symbol 类型的值)=="></a>数据类型 ==（ES6 又新增了第七种 Symbol 类型的值)==</h4><ol>
<li>数值（number）：整数和小数（比如1和3.14）</li>
<li>字符串（string）：文本（比如Hello World）。</li>
<li>布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）</li>
<li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li>
<li>null：表示空值，即此处的值为空。</li>
<li>对象（object）：各种值组成的集合。</li>
</ol>
<p>数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值</p>
<p>undefined和null，一般将它们看成两个特殊值</p>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ol>
<li>狭义的对象（object）</li>
<li>数组（array）</li>
<li>函数（function）</li>
</ol>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<ol>
<li>typeof运算符</li>
<li>instanceof运算符</li>
<li>Object.prototype.toString方法</li>
</ol>
<p>typeof运算符可以返回一个值的数据类型<br>数值、字符串、布尔值分别返回number、string、boolean</p>
<h4 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null, undefined"></a>null, undefined</h4><p>null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。</p>
<p>undefined表示“未定义”，下面是返回undefined的典型场景</p>
<p>转换规则是除了下面六个值被转为false，其他值都视为true。</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>0</li>
<li>NaN</li>
<li>“”或’’（空字符串）</li>
</ul>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合</p>
<h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h4><p>isNaN方法可以用来判断一个值是否为NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN) // true</span><br><span class="line">isNaN(123) // false</span><br></pre></td></tr></table></figure></p>
<p>但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&apos;Hello&apos;) // true</span><br><span class="line">// 相当于</span><br><span class="line">isNaN(Number(&apos;Hello&apos;)) // true****</span><br></pre></td></tr></table></figure></p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<p>需要用反斜杠转义的特殊字符，主要有下面这些。</p>
<ul>
<li>\0 ：null（\u0000）</li>
<li>\b ：后退键（\u0008）</li>
<li>\f ：换页符（\u000C）</li>
<li>\n ：换行符（\u000A）</li>
<li>\r ：回车键（\u000D）</li>
<li>\t ：制表符（\u0009）</li>
<li>\v ：垂直制表符（\u000B）</li>
<li>\’ ：单引号（\u0027）</li>
<li>\” ：双引号（\u0022）</li>
<li>\ ：反斜杠（\u005C）</li>
</ul>
<h4 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h4><p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">&apos;p&apos; in obj // true</span><br><span class="line">&apos;toString&apos; in obj // true</span><br></pre></td></tr></table></figure></p>
<p>in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。</p>
<p>这时，可以使用对象的==hasOwnProperty==方法判断一下，是否为对象自身的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">if (&apos;toString&apos; in obj) &#123;</span><br><span class="line">  console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域</p>
<p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var v = 1;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面的代码表明，函数f内部可以读取全局变量v。</p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  var v = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v // ReferenceError: v is not defined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var v = 1;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var v = 2;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 2</span><br><span class="line">v // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v</p>
<p>==注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var x = 5;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);  // 5</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var x = function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2</p>
<p>==总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域==</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n = 999;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = f1();</span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure>
<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<p>==闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在==</p>
<h4 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h4><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">var tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4><p>==数组的slice方法可以将“类似数组的对象”变成真正的数组==。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></p>
<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，==就是通过call()把数组的方法放到对象上面==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function print(value, index) &#123;</span><br><span class="line">  console.log(index + &apos; : &apos; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。</p>
<h4 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符"></a>取反运算符</h4><p>取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alse，false变成true。å</span><br><span class="line">!true // false</span><br><span class="line">!false // true</span><br></pre></td></tr></table></figure></p>
<p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>0</li>
<li>NaN</li>
<li>空字符串（’’）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!undefined // true</span><br><span class="line">!null // true</span><br><span class="line">!0 // true</span><br><span class="line">!NaN // true</span><br><span class="line">!&quot;&quot; // true</span><br><span class="line"></span><br><span class="line">!54 // false</span><br><span class="line">!&apos;hello&apos; // false</span><br><span class="line">![] // false</span><br><span class="line">!&#123;&#125; // false</span><br></pre></td></tr></table></figure>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h4><p>instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object(1);</span><br><span class="line">obj instanceof Object // true</span><br><span class="line">obj instanceof Number // true</span><br><span class="line"></span><br><span class="line">var obj = Object(&apos;foo&apos;);</span><br><span class="line">obj instanceof Object // true</span><br><span class="line">obj instanceof String // true</span><br><span class="line"></span><br><span class="line">var obj = Object(true);</span><br><span class="line">obj instanceof Object // true</span><br><span class="line">obj instanceof Boolean // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Object函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象</p>
<p>如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">var obj = Object(arr); // 返回原数组</span><br><span class="line">obj === arr // true</span><br><span class="line"></span><br><span class="line">var value = &#123;&#125;;</span><br><span class="line">var obj = Object(value) // 返回原对象</span><br><span class="line">obj === value // true</span><br><span class="line"></span><br><span class="line">var fn = function () &#123;&#125;;</span><br><span class="line">var obj = Object(fn); // 返回原函数</span><br><span class="line">obj === fn // true</span><br></pre></td></tr></table></figure>
<p>利用这一点，可以写一个判断变量是否为对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isObject(value) &#123;</span><br><span class="line">  return value === Object(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObject([]) // true</span><br><span class="line">isObject(true) // false</span><br></pre></td></tr></table></figure></p>
<h4 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h4><p>Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。</p>
<p>Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p1: 123,</span><br><span class="line">  p2: 456</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj) // [&quot;p1&quot;, &quot;p2&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p1: 123,</span><br><span class="line">  p2: 456</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj) // [&quot;p1&quot;, &quot;p2&quot;]</span><br></pre></td></tr></table></figure></p>
<p>对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;Hello&apos;, &apos;World&apos;];</span><br><span class="line"></span><br><span class="line">Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]</span><br><span class="line">Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<p>\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>[\b] 匹配退格键(U+0008)，不要与\b混淆。<br>\n 匹配换行键。<br>\r 匹配回车键。<br>\t 匹配制表符 tab（U+0009）。<br>\v 匹配垂直制表符（U+000B）。<br>\f 匹配换页符（U+000C）。<br>\0 匹配null字符（U+0000）。<br>\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。<br>\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</p>
<h4 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h4><p>预定义模式指的是某些常见模式的简写方式。</p>
<p>\d 匹配0-9之间的任一数字，相当于[0-9]。<br>\D 匹配所有0-9以外的字符，相当于[^0-9]。<br>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。<br>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。<br>\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。<br>\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。<br>\b 匹配词的边界。<br>\B 匹配非词边界，即在词的内部。</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4><ul>
<li>? 问号表示某个模式出现0次或1次，等同于{0, 1}</li>
<li><ul>
<li>星号表示某个模式出现0次或多次，等同于{0,}</li>
</ul>
</li>
<li><ul>
<li>加号表示某个模式出现1次或多次，等同于{1,}</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// t 出现0次或1次</span><br><span class="line">/t?est/.test(&apos;test&apos;) // true</span><br><span class="line">/t?est/.test(&apos;est&apos;) // true</span><br><span class="line"></span><br><span class="line">// t 出现1次或多次</span><br><span class="line">/t+est/.test(&apos;test&apos;) // true</span><br><span class="line">/t+est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t+est/.test(&apos;est&apos;) // false</span><br><span class="line"></span><br><span class="line">// t 出现0次或多次</span><br><span class="line">/t*est/.test(&apos;test&apos;) // true</span><br><span class="line">/t*est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;tttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;est&apos;) // true</span><br></pre></td></tr></table></figure>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<p>创建一个空对象，作为将要返回的对象实例。<br>将这个空对象的原型，指向构造函数的prototype属性。<br>将这个空对象赋值给函数内部的this关键字。<br>开始执行构造函数内部的代码。</p>
<h4 id="object-create"><a href="#object-create" class="headerlink" title="object.create()"></a>object.create()</h4><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">  age: 38,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    console.log(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person2 = Object.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name // 张三</span><br><span class="line">person2.greeting() // Hi! I&apos;m 张三.</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法</p>
<h4 id="this主要有以下几个使用场合"><a href="#this主要有以下几个使用场合" class="headerlink" title="this主要有以下几个使用场合"></a>this主要有以下几个使用场合</h4><p>全局环境</p>
<ul>
<li>. 全局环境使用this，它指的就是顶层对象window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this === window // true</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(this === window);</span><br><span class="line">&#125;</span><br><span class="line">f() // true</span><br></pre></td></tr></table></figure>
<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window</p>
<ul>
<li>. 构造函数<br>构造函数中的this，指的是实例对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Obj = function (p) &#123;</span><br><span class="line">  this.p = p;</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line">- 对象的方法</span><br><span class="line">如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Function.prototype.call()</span><br></pre></td></tr></table></figure>
<p>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<p>var obj = {};</p>
<p>var f = function () {<br>  return this;<br>};</p>
<p>f() === window // true<br>f.call(obj) === obj // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==call方法的一个应用是调用对象的原生方法==</span><br></pre></td></tr></table></figure></p>
<p>var obj = {};<br>obj.hasOwnProperty(‘toString’) // false</p>
<p>// 覆盖掉继承的 hasOwnProperty 方法<br>obj.hasOwnProperty = function () {<br>  return true;<br>};<br>obj.hasOwnProperty(‘toString’) // true</p>
<p>Object.prototype.hasOwnProperty.call(obj, ‘toString’) // false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果</span><br><span class="line">#### Function.prototype.apply()</span><br><span class="line">apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</span><br></pre></td></tr></table></figure></p>
<p>func.apply(thisValue, [arg1, arg2, …])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</span><br></pre></td></tr></table></figure></p>
<p>function f(x, y){<br>  console.log(x + y);<br>}</p>
<p>f.call(null, 1, 1) // 2<br>f.apply(null, [1, 1]) // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数</span><br><span class="line"></span><br><span class="line">（1）找出数组最大元素</span><br><span class="line">JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</span><br></pre></td></tr></table></figure></p>
<p>var a = [10, 2, 4, 15, 9];<br>Math.max.apply(null, a) // 15<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（2）将数组的空元素变为undefined</span><br><span class="line"></span><br><span class="line">通过apply方法，利用Array构造函数将数组的空元素变成undefined。</span><br></pre></td></tr></table></figure></p>
<p>Array.apply(null, [‘a’, ,’b’])<br>// [ ‘a’, undefined, ‘b’ ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。</span><br></pre></td></tr></table></figure></p>
<p>var a = [‘a’, , ‘b’];</p>
<p>function print(i) {<br>  console.log(i);<br>}</p>
<p>a.forEach(print)<br>// a<br>// b</p>
<p>Array.apply(null, a).forEach(print)<br>// a<br>// undefined<br>// b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==（3）转换类似数组的对象==</span><br><span class="line">，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</span><br></pre></td></tr></table></figure></p>
<p>Array.prototype.slice.apply({0: 1, length: 1}) // [1]<br>Array.prototype.slice.apply({0: 1}) // []<br>Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]<br>Array.prototype.slice.apply({length: 1}) // [undefined]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，==被处理的对象必须有length属性，以及相对应的数字键==</span><br><span class="line"></span><br><span class="line">（4）绑定回调函数的对象</span><br></pre></td></tr></table></figure></p>
<p>var o = new Object();</p>
<p>o.f = function () {<br>  console.log(this === o);<br>}</p>
<p>var f = function (){<br>  o.f.apply(o);<br>  // 或者 o.f.call(o);<br>};</p>
<p>// jQuery 的写法<br>$(‘#button’).on(‘click’, f);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法</span><br><span class="line">#### Function.prototype.bind()</span><br><span class="line">bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</span><br></pre></td></tr></table></figure></p>
<p>var d = new Date();<br>d.getTime() // 1481869925657</p>
<p>var print = d.getTime;<br>print() //<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了</span><br><span class="line">bind方法可以解决这个问题</span><br></pre></td></tr></table></figure></p>
<p>var print = d.getTime.bind(d);<br>print()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了</span><br><span class="line"></span><br><span class="line">bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。</span><br></pre></td></tr></table></figure></p>
<p>var counter = {<br>  count: 0,<br>  inc: function () {<br>    this.count++;<br>  }<br>};</p>
<p>var func = counter.inc.bind(counter);<br>func();<br>counter.count // 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。</span><br><span class="line"></span><br><span class="line">this绑定到其他对象也是可以的</span><br></pre></td></tr></table></figure></p>
<p>var counter = {<br>  count: 0,<br>  inc: function () {<br>    this.count++;<br>  }<br>};</p>
<p>var obj = {<br>  count: 100<br>};<br>var func = counter.inc.bind(obj);<br>func();<br>obj.count // 101<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性</span><br><span class="line"></span><br><span class="line">**如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）**</span><br><span class="line"></span><br><span class="line">（1）每一次返回一个新函数</span><br><span class="line">bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样</span><br><span class="line"></span><br><span class="line">（2）结合回调函数使用</span><br><span class="line">回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter</span><br><span class="line"></span><br><span class="line">还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。</span><br></pre></td></tr></table></figure></p>
<p>var obj = {<br>  name: ‘张三’,<br>  times: [1, 2, 3],<br>  print: function () {<br>    this.times.forEach(function (n) {<br>      console.log(this.name);<br>    });<br>  }<br>};</p>
<p>obj.print()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 没有任何输出</span><br><span class="line">上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</span><br></pre></td></tr></table></figure></p>
<p>obj.print = function () {<br>  this.times.forEach(function (n) {<br>    console.log(this === window);<br>  });<br>};</p>
<p>obj.print()<br>// true<br>// true<br>// true<br>解决这个问题，也是通过bind方法绑定this。</p>
<p>obj.print = function () {<br>  this.times.forEach(function (n) {<br>    console.log(this.name);<br>  }.bind(this));<br>};</p>
<p>obj.print()<br>// 张三<br>// 张三<br>// 张三<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（3）结合call方法使用</span><br><span class="line">利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例</span><br></pre></td></tr></table></figure></p>
<p>[1, 2, 3].slice(0, 1) // [1]<br>// 等同于<br>Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写</span><br></pre></td></tr></table></figure></p>
<p>var slice = Function.prototype.call.bind(Array.prototype.slice);<br>slice([1, 2, 3], 0, 1) // [1]<br><code>`</code><br>上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法</p>
<h4 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h4><p>原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>js规定 所有的对象都有一个自己的原型对象，一方面，任何一个对象都可以当着其他对象的原型对象，另一方面，原型对象它本身也是一个对象，所有它也有自己的原型，因此 就会形成一个原型链</p>
<h4 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h4><p>第一步是在子类的构造函数中，调用父类的构造函数<br>第二步是让子类的原型指向父类的原型，这样子类就可以继承父类原型</p>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/10/vue日记28/" rel="next" title="vue日记28">
                <i class="fa fa-chevron-left"></i> vue日记28
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">何方</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS笔记"><span class="nav-number">1.</span> <span class="nav-text">JS笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标识符"><span class="nav-number">1.0.1.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类型-（ES6-又新增了第七种-Symbol-类型的值"><span class="nav-number">1.0.2.</span> <span class="nav-text">数据类型 ==（ES6 又新增了第七种 Symbol 类型的值)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-运算符"><span class="nav-number">1.0.3.</span> <span class="nav-text">typeof 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null-undefined"><span class="nav-number">1.0.4.</span> <span class="nav-text">null, undefined</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NaN"><span class="nav-number">1.0.5.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isNaN"><span class="nav-number">1.0.6.</span> <span class="nav-text">isNaN()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转义"><span class="nav-number">1.0.7.</span> <span class="nav-text">转义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性是否存在：in-运算符"><span class="nav-number">1.0.8.</span> <span class="nav-text">属性是否存在：in 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数作用域"><span class="nav-number">1.0.9.</span> <span class="nav-text">函数作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数本身的作用域"><span class="nav-number">1.0.10.</span> <span class="nav-text">函数本身的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包"><span class="nav-number">1.0.11.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#立即调用的函数表达式"><span class="nav-number">1.0.12.</span> <span class="nav-text">立即调用的函数表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类似数组的对象"><span class="nav-number">1.0.13.</span> <span class="nav-text">类似数组的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取反运算符"><span class="nav-number">1.0.14.</span> <span class="nav-text">取反运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object"><span class="nav-number">1.0.15.</span> <span class="nav-text">Object()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys-，Object-getOwnPropertyNames"><span class="nav-number">1.0.16.</span> <span class="nav-text">Object.keys()，Object.getOwnPropertyNames()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊字符"><span class="nav-number">1.0.17.</span> <span class="nav-text">特殊字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预定义模式"><span class="nav-number">1.0.18.</span> <span class="nav-text">预定义模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#量词符"><span class="nav-number">1.0.19.</span> <span class="nav-text">量词符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-命令的原理"><span class="nav-number">1.0.20.</span> <span class="nav-text">new 命令的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object-create"><span class="nav-number">1.0.21.</span> <span class="nav-text">object.create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this主要有以下几个使用场合"><span class="nav-number">1.0.22.</span> <span class="nav-text">this主要有以下几个使用场合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prototype-属性的作用"><span class="nav-number">1.0.23.</span> <span class="nav-text">prototype 属性的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链"><span class="nav-number">1.0.24.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的继承"><span class="nav-number">1.0.25.</span> <span class="nav-text">构造函数的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单线程模型"><span class="nav-number">1.0.26.</span> <span class="nav-text">单线程模型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">何方</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
